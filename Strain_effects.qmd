---
title: "Investigating strain and developmental stage effects"
author: "Selcan Aydin"
date: "`r Sys.Date()`"
format: 
  html:
      embed-resources: true
      standalone: true
include-in-header:
  - text: |
      <style>
      .panel-tabset > .nav-tabs,
      .panel-tabset > .tab-content {
        border: none;
      }
      </style>
code-fold: true
toc: true
toc-depth: 5
toc-expand: true
editor: 
  markdown: 
    wrap: sentence
comments:
  hypothesis: 
    theme: clean
---

```{r setup}
#| message: false
#| warning: false

knitr::opts_chunk$set(message = NA, warning = NA)
# load packages
suppressPackageStartupMessages(library(tidyverse))

library(pheatmap)
library(plotly)
library(GGally)
library(ggpubr)
library(ggplot2)
library(corrplot)
library(simplifyEnrichment)

library(DESeq2)
library(DEGreport)
library(gprofiler2)
set_base_url("https://biit.cs.ut.ee/gprofiler_archive3/e108_eg55_p17/")
library(BioNERO)
set.seed(123) # for reproducibility
# library(WGCNA)

library(DT)

library(here)

select <- dplyr::select # I am adding this explicitly
rename <- dplyr::rename # I am adding this explicitly
filter <- dplyr::filter # I am adding this explicitly
summarize <- dplyr::summarize # I am adding this explicitly

# functions
create_dt <- function(x){
  DT::datatable(x,
                extensions = 'Buttons',
                rownames = FALSE, 
                filter="top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel'),
                               pageLength = 5, 
                               scrollX= TRUE
                               ))
  
}

# reading in the sample details
sample_details <- read_csv("/projects/munger-lab/projects/palate-project-murray-munger/samplesheet.csv") 

# domain colors
domain_colors <- c(PM=rgb(252,206,93, maxColorValue = 255), 
                   MAX=rgb(163,82,157, maxColorValue = 255), 
                   POST=rgb(158,156,201, maxColorValue = 255)
                   )

# strain colors
strain_colors <- c( B6 = "#555555", 
                    CAST = "#009E73",
                    DO = rgb(163,82,157, maxColorValue = 255))




```

```{r load_data_emase}
#| message: false
#| warning: false

# loading the count data
load("/projects/munger-lab/projects/palate-project-murray-munger/read_mapping/palate_gbrs_emase_counts_v4.RData") # raw_expr_mat, expr_mat_do, expr_mat_nondo 
expr_mat <- expr_mat_nondo
contam_samples <- c("B6_12.5_PM_1","B6_13.5_POST_3", "CAST_14.5_MAX_7", "B6_13.5_MAX_3")
expr_mat <- expr_mat[ ,!colnames(expr_mat) %in% contam_samples]
do_expr_mat <- expr_mat_do
remove_samples <- c("DO_13.5_MAX_6", "DO_13.5_MAX_14", "DO_13.5_MAX_14_2",
                    "DO_12.5_MAX_1" , "DO_12.5_MAX_2" ,"DO_13.5_MAX_97", "DO_13.5_MAX_96") # 96 & 97 are also 12.5 samples
do_expr_mat <- do_expr_mat[ ,!colnames(do_expr_mat) %in% remove_samples]

expr_mat_all <- cbind( expr_mat[intersect(rownames(expr_mat),rownames(do_expr_mat)),,drop=F],
                       do_expr_mat[intersect(rownames(expr_mat),rownames(do_expr_mat)),,drop=F])
rm(expr_mat_do, expr_mat_nondo)

# Get v105 annotations from biomart
all.genes_v105 <- read_tsv(here("_data","ENSMUSGid_to_symbol_v105.txt"),
                           col_names = c("gene_id","symbol","gene_biotype","chromosome","start","end"), skip =1) |>  
  mutate(midpoint = (start+end)/2)

all_genes_palate <- all.genes_v105 %>%
  filter(gene_id %in% rownames(raw_expr_mat))

# sample annotations
sample_annot <- sample_details %>% 
  #as_tibble( rownames = "sample") |> 
  filter( !sample %in% contam_samples & sample %in% colnames(expr_mat)) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) |> 
  mutate( LB_stage_binned = case_when(
    ( LB_stage < 12.25 )~"exclude",
    (between(LB_stage, 13.25, 13.5))~"exclude",
    (between(LB_stage, 12.25,12.75))~"1",
    (between(LB_stage, 13.5, 14))~"2",
    (between(LB_stage, 14.25, 14.75))~"3",
    (between(LB_stage, 15.1, 15.6))~"4"
  )) |> 
  mutate( LB_stage_binned = as_factor(LB_stage_binned))

sample_annot_all <- sample_details %>% 
  #as_tibble( rownames = "sample") |> 
  filter( !sample %in% contam_samples & sample %in% colnames(expr_mat_all)) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) 

# Genes from Ian:
pheno_gene_list <- readxl::read_xlsx(here("_data","Supp6_BoneGeneList.xlsx")) |> 
  select( symbol = gene_name) |> 
  distinct() |> 
  mutate(type = "pheno", type_long = "bone phenotype gene list (Sabik et al 2020, Table S6)")

skeletal_gene_table <- readxl::read_xlsx(here("_data","Skeletal_stem_progenitor_markers.xlsx")) |> 
  dplyr::rename("symbol" = "gene") |> 
  mutate(type = "MSC", type_long = "MSC/skeletal progenitor markers")

figure_genes <- c(MSC =c("Axin2","Gli1","Meis2","Lepr","Prrx1"),
           skeletal = c("Sox9","Runx2","Sp7","Nfatc1","Bcl11b","Msx2","Msx1","Egr1","Egr2"),
           osteoclast = c("Spi1","Tnfsf11","Tnfrsf11","PParg","Fos","Junb","Csf1","Csf1r","Ostf1",
                          "Acp5","Mmp9","Ctsk","Timp1","Atp6v0d2","Adgre1","Sfrp4","Dcstamp","Ocstamp","Htra1","Tcirg1","Itgb3","Gnptab"),
           osteoblast = c("Alpl","Ibsp","Phospho1","Vdr","Sparc","Panx3","Enpp1","Bglap","Bglap2","Clecl11a","Sost","Dmp1","Col1a1","Col1a2","Bgn","Dcn","Thbs2")
           
           ) |> 
  as_tibble(rownames = "type" ) |> 
  rename( symbol = value  ) |> 
  mutate(type = gsub("[0-9]","",type)) |> 
  mutate( type_long = case_when(type =="MSC"~"MSC/skeletal progenitor markers",
                                type =="skeletal"~"Skeletal speciation markers",
                                type =="osteoclast"~"Osteoclast markers",
                                type =="osteoblast"~"osteoblast/osteocyte markers"
                                )) 

morpho_genes <- readxl::read_xlsx(path = here("_data","abnormal craniofacial morphology-MGIBatchReport.xlsx")) |> 
  select(symbol = Symbol, mgi_id = `MGI Gene/Marker ID`, gene_biotype = `Feature Type`) 

# add gene names to MGI ids for genes
# checked the overlap
# length(intersect(mgi_id_annots$symbol, all_genes_palate$symbol)) # 16958/17146
# most of the missing ones are RPXX-YY genes or Gms
mgi_id_annots <- read_delim( file = here("_data","MRK_List1.rpt"),
                             #MGI Marker Accession ID	Chromosome	cM Position	Genome Coordinate Start	Genome Coordinate End	Genome Strand	Marker Symbol	Status	Marker Name	Marker Type	Feature Types (|-delimted)	Marker Synonyms (|-delimited)
                             col_names = c("mgi_id",
                                           "chromosome",
                                           "pos_cM",
                                           "start",
                                           "end",
                                           "strand",
                                           "symbol",
                                           "status",
                                           "marker_name",
                                           "marker_type",
                                           "feature_types",
                                           "marker_synms"), skip = 1) 

# getting the gene list for mammalian phenotypes
mp_genes <- read_delim( file = here("_data","MGI_PhenoGenoMP.rpt"),
                        # Allelic Composition	Allele Symbol(s)	Genetic Background	Mammalian Phenotype ID	PubMed ID	MGI Marker Accession ID (comma-delimited)
                        col_names = c("allelic_comp",
                                      "allele_symbol",
                                      "genetic_background",
                                      "mp_id",
                                      "pubmed_id",
                                      "mgi_id")) |> 
  select(mp_id, mgi_id) |> 
  distinct() |> 
  separate_longer_delim( mgi_id, delim = "|") |> 
  left_join(mgi_id_annots |> 
              select(mgi_id, symbol)) 
# add mammalian phenotype definitions
mp_defs <- read_delim( file = here("_data","VOC_MammalianPhenotype.rpt"),
                       col_names = c("mp_id","term_name","term_details")) 



genes <- full_join( figure_genes, skeletal_gene_table ) |> 
  #full_join( pheno_gene_list) |> 
  left_join(all_genes_palate)
# 
# genes |> 
#   group_by(symbol) |> 
#   mutate(n = n()) |> 
#   filter(n > 1) |> 
#   arrange(symbol)

```

This notebook is analyzing the palate gene expression from different genetic backgrounds, AP domains obtained at various gestational stages.
The first section uses the normalized gene expression counts from DO, B6 and CAST mice to look at sources of variation.
The second section focuses on B6 and CAST gene expression to specifically identify differentially expressed genes across domains, gestational stages and strain backgrounds.
Finally, the third section performs weighted gene co-expression network analysis using the gene expression data from B6 and CAST strains.
The genetic characterization of gene expression and developmental phenotypes using the DO strains can be found in `Palate_qtl_mapping.html` notebook.

```{r save_data_for_ian}
#| warning: false
#| message: false
#| eval: false
# loading the count data
load("/projects/munger-lab/projects/palate-project-murray-munger/read_mapping/palate_gbrs_emase_counts_v3.RData") # raw_expr_mat, expr_mat_do, expr_mat_nondo 

sample_annot <- sample_details %>% 
  filter( !sample %in% contam_samples ) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) 

expr_mat <- expr_mat_do |> 
  as_tibble(rownames = "gene_id") |> 
  full_join(
    expr_mat_nondo |> 
      as_tibble(rownames = "gene_id")
  ) |> 
  #select( any_of(c("gene_id",sample_annot$sample))) |> 
  column_to_rownames("gene_id") |> 
  as.matrix()

list( "normalized_gene_counts" = as_tibble(expr_mat[,sample_annot$sample,drop=F], rownames = "gene_id"),
      "raw_gene_counts" = as_tibble(raw_expr_mat[,sample_annot$sample,drop=F], rownames = "gene_id") ,
     "sample_annotations"=sample_annot,
     "gene_annotations" = all_genes_palate
     ) %>%
  openxlsx::write.xlsx(., file = here("_data","Gene_counts_for_Ian_12052023.xlsx"))

note <- paste0("Data saved on ", Sys.Date(), " by SA in rstudio Strain effects.qmd script.")
expr_mat <- expr_mat[,sample_annot$sample,drop=F]
raw_expr_mat <- raw_expr_mat[,sample_annot$sample,drop=F]
save( expr_mat,
      raw_expr_mat,
      sample_annot,
      all_genes_palate,
      note,
      file = here("_data","Gene_counts_for_Ian_12052023.RData")
     )

# downloadthis::download_file(
#   path = system.file(here("_data","Gene_counts_for_Ian_10162023.xlsx"),
#                           package = "downloadthis"),
#   output_name = "Gene counts for Ian",
#   button_label = "Download gene counts",
#   button_type = "primary",
#   has_icon = TRUE,
#   icon = "fa fa-save",
#   self_contained = FALSE
# )

pca <- prcomp( t( log1p( expr_mat[,sample_annot$sample,drop = F])), center = T, scale = F)
pca_df <- as_tibble(pca$x, rownames = "sample") %>% 
  left_join(sample_annot)
var_explained <- (pca$sdev^2 / sum(pca$sdev^2))
note <- paste0("Data saved on ", Sys.Date(), " by SA in rstudio Strain effects.qmd script.")
# saving RData files so he can run PCA and other things
save(
  pca,
  pca_df,
  var_explained,
  expr_mat,
  sample_annot,
  all_genes_palate,
  note,
  file = here("_data","Data_for_Ian_01302024.RData")
)

```

# Principal component analysis

Raw data was processed as follows:

-   Genes with a median transcript per million (TPM) lower than 0.5 were filtered while samples were grouped by gestational stage.
    The grouping is necessary because there are uniquely expressed genes in each stage.

-   Counts were normalized using variance stablizing transformation as implemented in DESeq2::vst() function..

In the final data set we have `r formatC(nrow(expr_mat_all), big.mark=",")` genes expressed across `r nrow(sample_annot_all)` samples.

Brief summary of PCA results:

-   First principal component (PC) groups samples by developmental time.

-   Second PC groups samples by strain background.

-   Fourth PC groups samples by AP domain.

-   PC5 and PC6 are highlighting a few DO samples that are highly similar to each other but differ from the rest of the samples.
    In the DO data, PC1 and PC2 separates these same samples from the rest of the DO samples.

-   PC7 groups samples based on sex.

```{r pca_b6_cast_do}
#| message: false
#| warning: false

# raw_colData <- sample_annot %>%
#   separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
#   select(-e,-d) %>%
#   mutate( rep = ifelse( is.na(rep),1,rep)) %>%
#   unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) %>%
#   select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage) %>%
#   filter(!is.na(sex) ) %>%
#   mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
#   column_to_rownames("sample")
# 
# raw_dds <- DESeqDataSetFromMatrix(countData = round(raw_expr_mat[,sample_annot$sample, drop = F]),
#                                   colData = sample_annot,
#                                   design = ~1)
# raw_dds_vst <- varianceStabilizingTransformation(raw_dds)
# assay(raw_dds, "vst") <- assay(raw_dds_vst)
# 
# pca <- prcomp(t(assay(raw_dds, "vst")), center=TRUE, scale=FALSE)


pca <- prcomp( t( log1p( expr_mat_all)), center = T, scale = F)
pca_df <- as_tibble(pca$x, rownames = "sample") %>% 
  left_join(sample_annot_all)
var_explained <- (pca$sdev^2 / sum(pca$sdev^2))

```

```{r pca_ora}
#| cache: true
#| message: false
#| warning: false

# pc drivers
pc1_drivers <- pca$rotation[,"PC1", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC1) >= quantile(abs(PC1), 0.95))

pc2_drivers <- pca$rotation[,"PC2", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC2) >= quantile(abs(PC2), 0.95))

pc3_drivers <- pca$rotation[,"PC3", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC3) >= quantile(abs(PC3), 0.95))

pc4_drivers <- pca$rotation[,"PC4", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC4) >= quantile(abs(PC4), 0.95))

pc5_drivers <- pca$rotation[,"PC5", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC5) >= quantile(abs(PC5), 0.95))

pc6_drivers <- pca$rotation[,"PC6", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC6) >= quantile(abs(PC6), 0.95))

pc7_drivers <- pca$rotation[,"PC7", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC7) >= quantile(abs(PC7), 0.95))


# ORA with pc drivers 1-5
# background


g.pc1 <- gost(
  query = pc1_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
g.pc1$result <- g.pc1$result %>% filter(term_size < 660)

g.pc2 <- gost(
  query = pc2_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
g.pc2$result <- g.pc2$result %>% filter(term_size < 660)

g.pc3 <- gost(
  query = pc3_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
if(length(g.pc3$result) >1) g.pc3$result <- g.pc3$result %>% filter(term_size < 660)

g.pc4 <- gost(
  query = pc4_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
if(length(g.pc4$result) >1) g.pc4$result <- g.pc4$result %>% filter(term_size < 660)

g.pc5 <- gost(
  query = pc5_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all.genes_v105$symbol,
  evcodes = TRUE,
  correction_method = "fdr"
)
if(length(g.pc5$result) >1) g.pc5$result <- g.pc5$result %>% filter(term_size < 660)

g.pc6 <- gost(
  query = pc6_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all.genes_v105$symbol,
  evcodes = TRUE,
  correction_method = "fdr"
)
if(length(g.pc6$result) >1) g.pc6$result <- g.pc6$result %>% filter(term_size < 660)


```

::: {#PCs .panel-tabset .nav-pills}
## Looking at first 10 PCs

By strain:

```{r first_five_pcs_emase_strain}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  left_join(sample_annot_all) %>%
  ggpairs(.,
    columns = 2:11, progress = FALSE, ggplot2::aes(color = strain, shape =strain),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  scale_color_manual( values = strain_colors)+
  scale_fill_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond", DO="square"))+
  # color_palette("npg")+
  # fill_palette("npg")+
  theme(legend.position = "right")

```

By gestational stage:

```{r first_five_pcs_emase_gest}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  left_join(sample_annot_all) %>%
  ggpairs(.,
    columns = 2:11, progress = FALSE, ggplot2::aes(shape = strain, color =Gest_stage),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  # scale_color_manual( values = strain_colors)+
  # scale_fill_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  scale_color_viridis_d()+
  scale_fill_viridis_d()+
  theme(legend.position = "right")

```

By sex:

```{r first_five_pcs_emase_sex}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  left_join(sample_annot_all) %>%
  ggpairs(.,
    columns = 2:11, progress = FALSE, ggplot2::aes(shape = strain, color =sex),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  # scale_color_manual( values = strain_colors)+
  # scale_fill_manual( values = strain_colors)+
  # scale_color_viridis_d()+
  # scale_fill_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  color_palette("npg")+
  fill_palette("npg")+
  theme(legend.position = "right")

```

Variation explained:

```{r scree_plot_emase}
#| message: false
#| warning: false
#| fig-width: 5
#| fig-height: 4

tibble(var =  var_explained[1:10]* 100, PC = paste0("PC", seq(1:10))) %>%
  arrange(desc(var)) %>%
  mutate(label = factor(PC, levels = PC)) %>%
  ggplot(aes(x = label, y = var)) +
  geom_col() +
  xlab("Principal Component") +
  ylab("% Variation explained") +
  theme_pubclean(base_size = 14)+
  ylim(0,25)


```

## PC1, PC2 and PC4

```{r pc123_3dplot}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

fig <- plot_ly(pca_df, 
               x = ~PC1, 
               y = ~PC2, 
               z = ~PC4,
               symbol = ~strain,
               symbols = c("circle","diamond","square"),
               text = ~sample,
               color = ~strain,
               colors = strain_colors,
               mode = "markers",
               type = "scatter3d"
)
fig <- fig %>% 
  layout(scene = list(xaxis = list(title = paste0("PC1 (",100*round(var_explained[1],2),"%)")),
                                   yaxis = list(title = paste0("PC2 (",100*round(var_explained[2],2),"%)")),
                                   zaxis = list(title = paste0("PC4 (",100*round(var_explained[4],2),"%)")))
)

fig

```

```{r pc123_3dplot_dom}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

fig <- plot_ly(pca_df, 
               x = ~PC1, 
               y = ~PC2, 
               z = ~PC4,
               color = ~AP_domain,
               symbol = ~strain,
               symbols = c("circle","diamond","square"),
               text = ~sample,
               colors = c(domain_colors),
               mode = "markers",
               type = "scatter3d"
)
fig <- fig %>% 
  layout(scene = list(xaxis = list(title = paste0("PC1 (",100*round(var_explained[1],2),"%)")),
                                   yaxis = list(title = paste0("PC2 (",100*round(var_explained[2],2),"%)")),
                                   zaxis = list(title = paste0("PC4 (",100*round(var_explained[4],2),"%)")))
)

fig

```

## PC1 groups samples by developmental time

```{r pc1_pc2_emase}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC1, 
       y = PC2,
       col = Gest_stage,
       shape = strain,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  #scale_color_manual( values = strain_colors)+
  scale_color_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  ylab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  theme(legend.position = "right")+
  labs(shape = "strain",
       col = "Gestational\nstage")


ggplotly(pca_plot, tooltip = c("label"))

```

```{r pc1_pc2_emase_lb}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC1, 
       y = PC2,
       shape = strain,
       #shape = Gest_stage,
       col = LB_stage,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  scale_color_viridis_c(limits = c(12,16))+
  #scale_color_manual(values=strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  ylab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  theme(legend.position = "right")+
  labs(color = "Limb bud\nstage",
       shape = "Strain")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC1 driver genes:

```{r pc1_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc1)

```

```{r pc1_ora_table}
#| message: false
#| warning: false


g.pc1$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%  # intersecion: adding the list of genes identified as overlapping with each category
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC1 driver genes:

```{r pc1_gene_table}
#| message: false
#| warning: false


pc1_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC1))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC2 and PC3 group samples by strain

```{r pc2_pc1_strain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC2, 
       y = PC1,
       col = strain,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  scale_color_viridis_d()+
  #color_palette("npg")+
  scale_color_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  ylab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC2 driver genes:

```{r pc2_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc2, capped = F)

```

```{r pc2_ora_table}

g.pc2$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC2 driver genes:

```{r pc2_gene_table}
#| message: false
#| warning: false


pc2_drivers %>% 
    left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC2))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

```{r pc2_pc3_domain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC3, 
       y = PC2,
       col = AP_domain,
       shape = strain,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #scale_color_viridis_c(limits = c(12,16))+
  scale_color_manual(values = domain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  xlab(paste0("PC3 (",100*round(var_explained[3],2),"%)"))+
  theme(legend.position = "right")+
  labs(color = "AP domain",
       shape = "Strain")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC3 driver genes:

```{r pc3_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc3, capped = T)

```

```{r pc3_ora_table}
#| eval: true
g.pc3$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC3 driver genes:

```{r pc3_gene_table}
#| message: false
#| warning: false


pc3_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC3))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC4 groups samples by domain

```{r pc1_pc4_domain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC4, 
       y = PC1,
       col = AP_domain,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  scale_color_manual( values = domain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC4 (",100*round(var_explained[4],2),"%)"))+
  ylab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC4 driver genes:

```{r pc4_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc4, capped = T)

```

```{r pc4_ora_table}

g.pc4$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC4 driver genes:

```{r pc4_gene_table}
#| message: false
#| warning: false


pc4_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC4))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC5 identifies outliers

```{r pc5_pc6}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>%
  filter( !is.na(sex)) %>%
  ggplot()+
  aes( x = PC1,
       y = PC5,
       col = LB_stage,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  scale_color_viridis_c(limits = c(12,16))+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC5 (",100*round(var_explained[5],2),"%)"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

Table with the full list of PC5 driver genes:

```{r pc56_gene_table}
#| message: false
#| warning: false


pc5_drivers %>% 
  mutate(PC = "PC5") |> 
  dplyr::rename( "value" = "PC5") |> 
  # rbind(
  #   pc6_drivers |> 
  #     mutate(PC = "PC6") |> 
  #     dplyr::rename("value" = "PC6")
  # ) |> 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC6 and PC7 group samples by sex

```{r pc7_pc1}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  filter( !is.na(sex)) %>% 
  ggplot()+
  aes( x = PC7, 
       y = PC6,
       col = sex,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  color_palette("npg")+
  #scale_color_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond"))+
  ylab(paste0("PC6 (",100*round(var_explained[6],2),"%)"))+
  xlab(paste0("PC7 (",100*round(var_explained[7],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

Table with the full list of PC6 and PC7 driver genes:

```{r pc7_gene_table}
#| message: false
#| warning: false


pc6_drivers %>% 
  mutate(PC = "PC6") |> 
  dplyr::rename("value" = "PC6") |> 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  rbind(
    pc7_drivers |>
      mutate(PC = "PC7") |>
      dplyr::rename("value" = "PC7") |> 
      left_join(
        all_genes_palate %>% 
          select(symbol, chromosome))
  ) |>
  #arrange(desc(abs(PC7))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```
:::

# Gene set variation analysis

Add GSVA here with:

-   GO BP

-   MGI mammalian phenotypes


```{r run_gsva}
#| warning: false
#| message: false
#| results: hide
#| cache: true

# reading in the GO + mgi downloaded from: http://www.informatics.jax.org/gotools/data/input/MGIgenes_by_GOid.txt
go_terms <- read_tsv( "http://www.informatics.jax.org/gotools/data/input/MGIgenes_by_GOid.txt") %>% 
  mutate( genes = str_split(genes, ",")) %>% 
  unnest() # separete the symbols, note the overlap: length(intersect(unique(go_terms$genes), npc.genes$mgi_symbol) ) = 11806


slim_go_terms <- read_tsv( "http://www.informatics.jax.org/gotools/data/input/map2MGIslim.txt") %>% 
  select(-term) %>% 
  mutate( ONT = case_when( aspect == "P" ~  "BP",
                     aspect == "F" ~ "MF",
                     aspect == "C" ~ "CC"
                     )
          ) %>% 
  select(-aspect)

genesbygo <- split(go_terms$genes, go_terms$GO_id)

go_terms_annot <- go_terms %>%  
  select(GO_id) %>% 
  distinct() %>% 
  left_join( slim_go_terms %>%  select( GO_id, ONT) %>% distinct())

goannot_wdef <- AnnotationDbi::select(GO.db::GO.db, keys= unique(go_terms$GO_id), columns=c("GOID","DEFINITION","ONTOLOGY","TERM")) %>%
  left_join( slim_go_terms, by=c("GOID"="GO_id")) %>% 
  mutate( ONTOLOGY = ONT) %>% 
  select(-ONT)

go_bp <- goannot_wdef %>% filter( ONTOLOGY == "BP") %>% 
  select(GOID) %>%  distinct()

# adding mammalian phenotypes!
genesbyMP <- split(mp_genes$symbol, mp_genes$mp_id)

# expr - change gene id's to symbols for GSVA with GO
expr.upd <- expr_mat[all_genes_palate$gene_id,]
rownames(expr.upd) <- all_genes_palate$symbol

# run gsva
gsva_go <- GSVA::gsva(  expr = expr.upd,
                   gset.idx.list = genesbygo,
                    method ="gsva",
                    kcdf = "none",
                    min.sz = 5,
                    max.sz = 1000,
                    mx.diff = TRUE
                   )

gsva_mp <- GSVA::gsva(  expr = expr.upd,
                   gset.idx.list = genesbyMP,
                    method ="gsva",
                    kcdf = "none",
                    min.sz = 5,
                    max.sz = 5000, # setting to 1000 only removes 6 gene sets
                    mx.diff = TRUE
                   )

# following up on rna results
gsva_go %>% 
  as_tibble(rownames = "Category") %>% 
  filter( Category %in% go_bp$GOID) %>% #filtering for BP
  rbind( gsva_mp |> 
           as_tibble( rownames = "Category")) |> 
  pivot_longer( cols = colnames(expr.upd),
                values_to = "Enrichment_Score",
                names_to = "sample") %>% 
  # add covariates 
  left_join( sample_annot %>% 
               select(sample, sex, strain, AP_domain,LB_stage_binned)) -> gsva_results

gsva_results %>% 
  group_by( Category) %>% 
  rstatix::anova_test( Enrichment_Score ~ strain+AP_domain+LB_stage_binned) %>% 
  rstatix::adjust_pvalue( method = "BH") %>%
  rstatix::add_significance("p.adj") %>% 
  ungroup() -> gsva_aov

gsva_results %>% 
  group_by(Category) %>% 
  rstatix::tukey_hsd( Enrichment_Score ~ strain+AP_domain+LB_stage_binned) %>% 
  ungroup() %>% 
  as_tibble() -> gsva_tukey

gsva_aov %>% 
  as_tibble() %>% 
  filter( p.adj.signif != "ns" & !is.na(p.adj) ) -> signif_eff_terms

gsva_tukey %>% 
  inner_join( ., select( signif_eff_terms, Category, term = Effect)) -> signif_results_tukey

```

Below are the list of GO Biological processes that show significant differences by strain, AP domain and LB stage (adjusted p-value \< 0.05).


### GO BP terms and mammalian phenotypes showing significant differences 

```{r gsva_results_table}
#| warning: false
#| message: false
#| eval: false


signif_eff_terms %>% 
  filter( p.adj<0.05) %>% 
  filter( str_detect(Category, "GO:")) |> 
  left_join( goannot_wdef |> 
               select(Category = GOID, TERM) |> 
               distinct()) |> 
  rbind(
    signif_eff_terms |> 
      filter( p.adj < 0.01) |> 
      filter(str_detect(Category, "MP:")) |> 
      left_join( mp_defs |> 
                   select(Category = mp_id,
                          TERM = term_name))
  ) |> 
  select(Effect, Category, TERM,p.adj) %>% 
  #filter( p.adj < 0.01) %>% 
  distinct() %>% 
  mutate( "Adjusted p-value" = formatC(p.adj, digits=2, format ="e")) %>% 
  select(-p.adj) %>% 
  create_dt()



  
```

Let's simplify the GO terms that show significant differences between LB stage bins:

```{r simplify_gsva_lb}
#| warning: false
#| message: false
#| fig-height: 8
#| fig-width: 16
#| cache: true


gsva_lb_stage_terms <- signif_eff_terms %>% 
  filter( p.adj<0.01, Effect == "LB_stage_binned", str_detect(Category, "GO")) 

simplifyGO( mat = GO_similarity(gsva_lb_stage_terms$Category, ont = "BP"))

#compare_clustering_methods(GO_similarity(gsva_pn_go_terms$Category, ont = "BP"))

```

strain:
```{r simplify_gsva_strain}
#| warning: false
#| message: false
#| fig-height: 8
#| fig-width: 16
#| cache: true


gsva_strain_terms <- signif_eff_terms %>% 
  filter( p.adj<0.01, Effect == "strain", str_detect(Category, "GO")) 

simplifyGO( mat = GO_similarity(gsva_strain_terms$Category, ont = "BP"))



```

AP domain:
```{r simplify_gsva_domain}
#| warning: false
#| message: false
#| fig-height: 8
#| fig-width: 16
#| cache: true


gsva_domain_terms <- signif_eff_terms %>% 
  filter( p.adj<0.01, Effect == "AP_domain", str_detect(Category, "GO")) 

simplifyGO( mat = GO_similarity(gsva_domain_terms$Category, ont = "BP"))


```


# Weighted gene co-expression network analysis (WGCNA) with B6 data

```{r}
#| label: prep_for_wgcna_b6
#| warning: false
#| message: false

b6_samples <- sample_annot %>%
  filter(strain %in% c("B6")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
b6_cts_all <- round(raw_expr_mat[,rownames(b6_samples), drop = F])
b6_dds_all <- DESeqDataSetFromMatrix( countData = b6_cts_all,
                                  colData = b6_samples,
                                  design = ~1)
b6_dds_all <- collapseReplicates(b6_dds_all, b6_dds_all$unique_sampleid)
b6_dds_all_norm <- vst(b6_dds_all)
# b6_datExpr <- t(assay(b6_dds_all_norm))
b6_coldata <- colData(b6_dds_all) |> 
  as_tibble() |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")


# b6_gsg <- goodSamplesGenes(b6_datExpr)
# summary(b6_gsg)
b6_datTraits <- colData(b6_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, strain) %>%
  mutate( strain = ifelse( strain == "B6",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
b6_datTraits_alt <- colData(b6_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, strain) %>%
  column_to_rownames("unique_sampleid")


# # Following Ian's analysis to get most variable genes
# B6rv_wpn <- rowVars(assay(b6_dds_all_norm))
# #summary(B6rv_wpn)
# 
# B6q75_wpn <- quantile( rowVars(assay(b6_dds_all_norm)), .75)  # <= original
# B6q95_wpn <- quantile( rowVars(assay(b6_dds_all_norm)), .95)  # <= changed to 95 quantile to reduce dataset
# b6_datExpr <- t(assay(b6_dds_all_norm)[ B6rv_wpn > B6q95_wpn, ])

# I am not filtering by the most variable genes.
# Just initially filtering to only include the genes that passed our initial tpm thresholding
b6_expr <- SummarizedExperiment(assays=list(counts=log1p(assay(b6_dds_all_norm)[rownames(expr_mat),,drop=F])),
                     colData=b6_datTraits_alt)




```

```{r choose_sftpower_b6}
#| warning: false
#| message: false
#| results: hide

# Choose a set of soft-thresholding powers
b6_sft <- SFT_fit(b6_expr, net_type = "signed", cor_method = "pearson")
```

```{r}
#| label: sft_power_plot_b6
#| fig-width: 12
#| fig-height: 5
b6_sft$plot 
```


```{r run_wgcna_b6}
#| warning: false
#| message: false
#| results: hide

power_b6 <- 12#b6_sft$power

net_b6 <- exp2gcn(
    b6_expr, 
    net_type = "signed", 
    SFTpower = power_b6, 
    cor_method = "pearson"
)

# plot_dendro_and_colors(net_b6)
# plot_eigengene_network(net_b6)
# plot_ngenes_per_module(net_b6)

```


Assessing module stability by re-sampling:

```{r}
#| label: module_stability_b6
#| warning: false
#| message: false
#| cache: false
#| results: hide
#| eval: false
 

module_stability(b6_expr, net_b6, nRuns = 50)


```


Using `r formatC(nrow(b6_expr),big.mark=",")` genes and `r formatC(ncol(b6_expr),big.mark=",")` samples. This leads to `r ncol(net_b6$MEs)` modules in total which are characterized below.


::: {#WGCNA_results .panel-tabset .nav-pills}
### Module genes

::: {#WGCNA_module_genes .panel-tabset .nav-pills}
```{r module_gene_expr_plots}
#| warning: false
#| message: false
#| results: asis
#| fig-width: 10
#| fig-height: 10

module_genes <- net_b6$genes_and_modules

b6_coldata_ordered <- b6_coldata |> 
  as_tibble(rownames = "sample") |> 
  arrange(Gest_stage,AP_domain) |> 
  column_to_rownames("sample") |> 
  as.matrix()
  
for( mod_col in unique(module_genes$Modules)){
  mod_genes <- module_genes |> 
    filter(Modules ==mod_col)
  
  cat("\n####",mod_col, "module","\n")
  p <- pheatmap(mat = log1p((assay(b6_expr)[mod_genes$Genes,rownames(b6_coldata_ordered), drop = FALSE])),
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = b6_coldata[,c("AP_domain","LB_stage")],
         annotation_colors = list( 
                    #strain = strain_colors[c("B6","CAST")],
                    AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
            )
         #breaks = seq(5, 25, 1)
  )
  print(p)
  cat("\n\n")
  # print(mod_genes |>
  #   inner_join( strain_eff_genes_merged ) |>
  #   select(module = moduleColors,gene_id, symbol, baseMean, log2FoldChange, padj,test) |>
  #   mutate_if(is.numeric, formatC, digits = 2) |>
  #   create_dt())
  # cat("\n\n")
}        
         
```
:::


### Module eigengenes

```{r module_eigengene_plots_2}
#| warning: false
#| message: false
#| results: asis
#| fig-width: 30
#| fig-height: 18

module_eigenges <- net_b6$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(b6_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long <-  module_eigenges |> 
  pivot_longer( MElightpink4:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = AP_domain)+
    geom_jitter()+
    geom_smooth( aes(col = AP_domain))+
    scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 4)


```

::: {#WGCNA_module_eigengenes .panel-tabset .nav-pills}
```{r module_eigengene_plots}
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

module_eigenges <- net_b6$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(b6_coldata |> 
              as_tibble(rownames= "sample"))

module_eigengenes_long <-  module_eigenges |> 
  pivot_longer( 2:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

plot_eigengene_by_samples <- function(mod_name){
  
  df <- module_eigengenes_long |> 
    filter( module == mod_name) |> 
    arrange( value) |> 
    mutate( sample = as_factor(sample))
  
  eigengene_plot <- df |> 
    ggplot()+
    aes( y = value, x= sample, fill = mod_col)+
    geom_bar(stat = "identity", col = "black")+
    scale_fill_manual( values = gsub("ME","",mod_name))+
    #scale_color_manual( values = module_colors)+
    theme_pubclean()+
    theme( legend.position = "none",
           axis.text.x = element_blank(),
          axis.ticks.x = element_blank())+
    xlab("")+
    ylab("Module summary eigengene")
    #facet_wrap(~module)

    # strain_annot_plot <- df |> 
    #   ggplot()+
    #   aes( y = 1, x= sample, fill=strain,col = strain)+
    #   geom_tile()+
    #   theme_pubclean(base_size = 8)+
    #   scale_fill_manual(values = strain_colors)+
    #   scale_color_manual(values = strain_colors)+
    #   theme( legend.position = "bottom",
    #          legend.key.height =  unit(0.2, 'cm'),
    #          axis.text.x = element_blank(),
    #          axis.ticks.x = element_blank(),
    #          axis.text.y = element_blank(),
    #          axis.ticks.y = element_blank())+
    #   xlab("")+
    #   ylab("")
    
    dom_annot_plot <- df|>
        ggplot()+
        aes( y = 1, x= sample, fill=AP_domain,col = AP_domain)+
        geom_tile()+
        theme_pubclean(base_size = 8)+
        scale_fill_manual(values = domain_colors)+
        scale_color_manual(values = domain_colors)+
        theme( legend.position = "bottom",
               legend.key.height =  unit(0.2, 'cm'),
               axis.text.x = element_blank(),
               axis.ticks.x = element_blank(),
               axis.text.y = element_blank(),
               axis.ticks.y = element_blank())+
        xlab("")+
        ylab("")
    
    stage_annot_plot <- df |> 
        ggplot()+
        aes( y = 1, x= sample, fill=LB_stage,col = LB_stage)+
        geom_tile()+
        theme_pubclean(base_size = 8)+
        scale_color_viridis_c(begin = 0, end = 1, direction = -1, option = "D")+
        scale_fill_viridis_c(begin = 0, end = 1, direction = -1, option = "D")+
        theme( legend.position = "bottom",
               legend.key.height =  unit(0.2, 'cm'),
               axis.text.x = element_blank(),
               axis.ticks.x = element_blank(),
               axis.text.y = element_blank(),
               axis.ticks.y = element_blank())+
        xlab("")+
        ylab("")
      plot <- ggarrange(eigengene_plot, 
                #ggarrange(NULL,strain_annot_plot, nrow =1 , widths = c(0.05,1)), 
                ggarrange(NULL,dom_annot_plot, nrow =1 , widths = c(0.05,1)),
                ggarrange(NULL,stage_annot_plot, nrow =1 , widths = c(0.05,1)),
                nrow = 4, heights = c(1.5,0.5,0.5) )
    return(plot)
}

module_colors <- unique(module_eigengenes_long$mod_col)
names(module_colors) <- paste0("ME",module_colors)

for(mod in names(module_colors)){
  
  cat("\n####",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_samples(mod))
  cat("\n \n")
  
}

# a <- plot_eigengene_by_samples("MEblack")
# ggsave(a, filename = here("_figures","test.pdf"), width = 8, height = 6)

```

:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_b6
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
b6_me_trait_cor <- c()
for(i in 1:(ncol(b6_datTraits_alt)-1)){
  
  b6_me_trait_cor[[colnames(b6_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(b6_expr), # get just the expression
                                            metadata = b6_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_b6$MEs,
                                            continuous_trait = is.numeric(b6_datTraits_alt[1,i]),
                                            palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp <- reshape2::melt(b6_me_trait_cor) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  rename( "group"="L1") |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat <- reshape2::dcast(corandp, ME ~ trait, value.var = "cor")
rownames(cormat) <- cormat$ME
cormat$ME <- NULL
cormat <- as.matrix(cormat)
cormat[is.na(cormat)] <- 0

pmat <- reshape2::dcast(corandp, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat) <- pmat$ME
pmat$ME <- NULL
pmat[is.na(pmat)] <- ""

# # Get row and column annotation to decorate the heatmap
# rowdata <- data.frame(row.names = rownames(cormat), Module = rownames(cormat))
# coldata <- corandp[!duplicated(corandp$trait), ]
# coldata <- data.frame(row.names = coldata$trait, Trait = coldata$group)
# 
# # Plot heatmap
# pal <- colorRampPalette(rev(RColorBrewer::brewer.pal(10, "PRGn")))(100)
# 
# hm <- pheatmap(
#         mat = cormat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F],
#         name = "Correlation",
#         color = pal,
#         #display_numbers = textmat,
#         main = "Module-trait correlations",
#         legend_breaks = seq(-1, 1, 0.5),
#         breaks = seq(-1, 1, 0.02),
#         #annotation_row = rowdata,
#         annotation_col = coldata,
#         #annotation_colors = cols,
#         row_split = NULL,
#         column_split = coldata$Trait,
#         cluster_cols = F
#     )
```

```{r}
#| label: module_trait_cor_plot_b6
#| fig-width: 8
#| fig-height: 12
corrplot(corr = cormat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F],
         p.mat = as.matrix(pmat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(8,10), ylim=c(2,12), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r module_trait_cor_table}
#| warning: false
#| message: false
cormat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:7, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:7, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

**Add mammalian phenotypes here using the bionero ORA function!**

```{r wgcna_module_ora}
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
ora_results <- c()
modules <- unique(net_b6$genes_and_modules$Modules)
for( mod in modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_b6$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = all_genes_palate$symbol,
                        evcodes = TRUE)
  ora_results[[mod]] <- g.mod
}

```

```{r wgcna_ora_restuls_table}
#| eval: true
do.call( rbind, ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```
:::


# WGCNA with top 5% variable genes in CAST data


```{r}
#| message: false
#| warning: false
#| label: wgcna_prep_cast
#| results: hide

# Let's prep the cast samples for later use here too
cast_samples <- sample_annot %>%
  filter(strain %in% c("CAST")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
cast_cts_all <- round(raw_expr_mat[,rownames(cast_samples), drop = F])
cast_dds_all <- DESeqDataSetFromMatrix( countData = cast_cts_all,
                                  colData = cast_samples,
                                  design = ~1)
cast_dds_all <- collapseReplicates(cast_dds_all, cast_dds_all$unique_sampleid)
cast_dds_all_norm <- vst(cast_dds_all)
# cast_datExpr <- t(assay(cast_dds_all_norm))
cast_coldata <- colData(cast_dds_all) |> 
  as_tibble() |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")


# cast_gsg <- goodSamplesGenes(cast_datExpr)
# summary(cast_gsg)
cast_datTraits <- colData(cast_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, strain) %>%
  mutate( strain = ifelse( strain == "B6",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
cast_datTraits_alt <- colData(cast_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, strain) %>%
  column_to_rownames("unique_sampleid")
# # Following Ian's analysis to get most variable genes
# CASTrv_wpn <- rowVars(assay(cast_dds_all_norm))
# #summary(B6rv_wpn)
# 
# CASTq75_wpn <- quantile( rowVars(assay(cast_dds_all_norm)), .75)  # <= original
# CASTq95_wpn <- quantile( rowVars(assay(cast_dds_all_norm)), .95)  # <= changed to 95 quantile to reduce dataset
# cast_datExpr <- t(assay(cast_dds_all_norm)[ CASTrv_wpn > CASTq95_wpn, ])
# # convert to summarized experiment object for later use in bionero functions
# cast_expr <- SummarizedExperiment(assays=list(counts=t(cast_datExpr)),
#                      colData=cast_datTraits_alt)

# I am not filtering by the most variable genes.
# Just initially filtering to only include the genes that passed our initial tpm thresholding
cast_expr <- SummarizedExperiment(assays=list(counts=log1p(assay(cast_dds_all_norm)[rownames(expr_mat),,drop=F])),
                     colData=cast_datTraits_alt)

```


```{r choose_sftpower_cast}
#| warning: false
#| message: false
#| results: hide

# Choose a set of soft-thresholding powers
cast_sft <- SFT_fit(cast_expr, net_type = "signed", cor_method = "pearson")

```

```{r}
#| label: sft_power_plot_cast
cast_sft$plot 
```


```{r run_wgcna_cast}
#| warning: false
#| message: false
#| results: hide

power_cast <- cast_sft$power

net_cast <- exp2gcn(
    cast_expr, 
    net_type = "signed", 
    SFTpower = power_cast, 
    cor_method = "pearson"
)

plot_dendro_and_colors(net_cast)
plot_eigengene_network(net_cast)
plot_ngenes_per_module(net_cast)

```


Assessing module stability by re-sampling:

```{r}
#| label: module_stability_cast
#| message: false
#| warning: false
#| cache: true
#| results: hide
#| eval: false

module_stability(cast_expr, net_cast, nRuns = 50)
```


Using `r formatC(nrow(cast_expr),big.mark=",")` genes and `r formatC(ncol(cast_expr),big.mark=",")` samples. This leads to `r ncol(net_cast$MEs)` modules in total which are characterized below.


::: {#WGCNA_results .panel-tabset .nav-pills}
### Module genes

::: {#WGCNA_module_genes .panel-tabset .nav-pills}
```{r module_gene_expr_plots_cast}
#| warning: false
#| message: false
#| results: asis
#| fig-width: 10
#| fig-height: 10

module_genes <- net_cast$genes_and_modules

cast_coldata_ordered <- cast_coldata |> 
  as_tibble(rownames = "sample") |> 
  arrange(Gest_stage,AP_domain) |> 
  column_to_rownames("sample") |> 
  as.matrix()
  
for( mod_col in unique(module_genes$Modules)){
  mod_genes <- module_genes |> 
    filter(Modules ==mod_col)
  
  cat("\n####",mod_col, "module","\n")
  p <- pheatmap(mat = log1p((assay(cast_expr)[mod_genes$Genes,rownames(cast_coldata_ordered), drop = FALSE])),
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = cast_coldata[,c("AP_domain","LB_stage")],
         annotation_colors = list( 
                    #strain = strain_colors[c("cast","CAST")],
                    AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
            )
         #breaks = seq(5, 25, 1)
  )
  print(p)
  cat("\n\n")
  # print(mod_genes |>
  #   inner_join( strain_eff_genes_merged ) |>
  #   select(module = moduleColors,gene_id, symbol, baseMean, log2FoldChange, padj,test) |>
  #   mutate_if(is.numeric, formatC, digits = 2) |>
  #   create_dt())
  # cat("\n\n")
}        
         
```
:::


### Module eigengenes

```{r module_eigengene_plots_cast}
#| warning: false
#| message: false
#| results: asis
#| fig-width: 18
#| fig-height: 15

module_eigenges <- net_cast$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(cast_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long <-  module_eigenges |> 
  pivot_longer( 2:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = AP_domain)+
    geom_jitter()+
    geom_smooth( aes(col = AP_domain))+
    scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 3)


```

::: {#WGCNA_module_eigengenes .panel-tabset .nav-pills}
```{r module_eigengene_plots_cast_2}
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

module_eigenges <- net_cast$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(cast_coldata |> 
              as_tibble(rownames= "sample"))

module_eigengenes_long <-  module_eigenges |> 
  pivot_longer(2:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

plot_eigengene_by_samples <- function(mod_name){
  
  df <- module_eigengenes_long |> 
    filter( module == mod_name) |> 
    arrange( value) |> 
    mutate( sample = as_factor(sample))
  
  eigengene_plot <- df |> 
    ggplot()+
    aes( y = value, x= sample, fill = mod_col)+
    geom_bar(stat = "identity", col = "black")+
    scale_fill_manual( values = gsub("ME","",mod_name))+
    #scale_color_manual( values = module_colors)+
    theme_pubclean()+
    theme( legend.position = "none",
           axis.text.x = element_blank(),
          axis.ticks.x = element_blank())+
    xlab("")+
    ylab("Module summary eigengene")
    #facet_wrap(~module)

    # strain_annot_plot <- df |> 
    #   ggplot()+
    #   aes( y = 1, x= sample, fill=strain,col = strain)+
    #   geom_tile()+
    #   theme_pubclean(base_size = 8)+
    #   scale_fill_manual(values = strain_colors)+
    #   scale_color_manual(values = strain_colors)+
    #   theme( legend.position = "bottom",
    #          legend.key.height =  unit(0.2, 'cm'),
    #          axis.text.x = element_blank(),
    #          axis.ticks.x = element_blank(),
    #          axis.text.y = element_blank(),
    #          axis.ticks.y = element_blank())+
    #   xlab("")+
    #   ylab("")
    
    dom_annot_plot <- df|>
        ggplot()+
        aes( y = 1, x= sample, fill=AP_domain,col = AP_domain)+
        geom_tile()+
        theme_pubclean(base_size = 8)+
        scale_fill_manual(values = domain_colors)+
        scale_color_manual(values = domain_colors)+
        theme( legend.position = "bottom",
               legend.key.height =  unit(0.2, 'cm'),
               axis.text.x = element_blank(),
               axis.ticks.x = element_blank(),
               axis.text.y = element_blank(),
               axis.ticks.y = element_blank())+
        xlab("")+
        ylab("")
    
    stage_annot_plot <- df |> 
        ggplot()+
        aes( y = 1, x= sample, fill=LB_stage,col = LB_stage)+
        geom_tile()+
        theme_pubclean(base_size = 8)+
        scale_color_viridis_c(begin = 0, end = 1, direction = -1, option = "D")+
        scale_fill_viridis_c(begin = 0, end = 1, direction = -1, option = "D")+
        theme( legend.position = "bottom",
               legend.key.height =  unit(0.2, 'cm'),
               axis.text.x = element_blank(),
               axis.ticks.x = element_blank(),
               axis.text.y = element_blank(),
               axis.ticks.y = element_blank())+
        xlab("")+
        ylab("")
      plot <- ggarrange(eigengene_plot, 
                #ggarrange(NULL,strain_annot_plot, nrow =1 , widths = c(0.05,1)), 
                ggarrange(NULL,dom_annot_plot, nrow =1 , widths = c(0.05,1)),
                ggarrange(NULL,stage_annot_plot, nrow =1 , widths = c(0.05,1)),
                nrow = 4, heights = c(1.5,0.5,0.5) )
    return(plot)
}

module_colors <- unique(module_eigengenes_long$mod_col)
names(module_colors) <- paste0("ME",module_colors)

for(mod in names(module_colors)){
  
  cat("\n#### ",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_samples(mod))
  cat("\n \n")
  
}

# a <- plot_eigengene_by_samples("MEblack")
# ggsave(a, filename = here("_figures","test.pdf"), width = 8, height = 6)

```

:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_cast
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
cast_me_trait_cor <- c()
for(i in 1:(ncol(cast_datTraits_alt)-1)){
  
  cast_me_trait_cor[[colnames(cast_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(cast_expr), # get just the expression
                                            metadata = cast_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_cast$MEs,
                                            continuous_trait = is.numeric(cast_datTraits_alt[1,i]),
                                            palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp <- reshape2::melt(cast_me_trait_cor) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  rename( "group"="L1") |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat <- reshape2::dcast(corandp, ME ~ trait, value.var = "cor")
rownames(cormat) <- cormat$ME
cormat$ME <- NULL
cormat <- as.matrix(cormat)
cormat[is.na(cormat)] <- 0

pmat <- reshape2::dcast(corandp, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat) <- pmat$ME
pmat$ME <- NULL
pmat[is.na(pmat)] <- ""

# # Get row and column annotation to decorate the heatmap
# rowdata <- data.frame(row.names = rownames(cormat), Module = rownames(cormat))
# coldata <- corandp[!duplicated(corandp$trait), ]
# coldata <- data.frame(row.names = coldata$trait, Trait = coldata$group)
# 
# # Plot heatmap
# pal <- colorRampPalette(rev(RColorBrewer::brewer.pal(10, "PRGn")))(100)
# 
# hm <- pheatmap(
#         mat = cormat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F],
#         name = "Correlation",
#         color = pal,
#         #display_numbers = textmat,
#         main = "Module-trait correlations",
#         legend_breaks = seq(-1, 1, 0.5),
#         breaks = seq(-1, 1, 0.02),
#         #annotation_row = rowdata,
#         annotation_col = coldata,
#         #annotation_colors = cols,
#         row_split = NULL,
#         column_split = coldata$Trait,
#         cluster_cols = F
#     )
```

```{r}
#| label: module_trait_cor_plot_cast
#| fig-width: 6
#| fig-height: 8
corrplot(corr = cormat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F],
         p.mat = as.matrix(pmat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(8,10), ylim=c(2,12), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r module_trait_cor_table_cast}
#| warning: false
#| message: false
cormat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:7, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat[,c("M","F","PM","MAX","POST","LB_stage"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:7, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

**Add mammalian phenotypes here using the bionero ORA function!**

```{r wgcna_module_ora_cast}
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
cast_ora_results <- c()
cast_modules <- unique(net_cast$genes_and_modules$Modules)
for( mod in cast_modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_cast$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = all_genes_palate$symbol,
                        evcodes = TRUE)
  cast_ora_results[[mod]] <- g.mod
}

```

```{r wgcna_ora_restuls_table_cast}
#| eval: true
do.call( rbind, cast_ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```
:::



# WGCNA: Consensus module and module preservation analysis

"Although they seem similar, their goals are opposite: while consensus modules identification focuses on the commonalities, module preservation focuses on the divergences."

```{r}
#| label: prep_data_for_bionero
#| warning: false
#| message: false
#| results: hide

common_genes <- intersect(rownames(b6_expr), rownames(cast_expr))
b6_cast_data <- list( B6 = log1p(assay(b6_expr)[common_genes,]), CAST = log1p(assay(cast_expr)[common_genes,]))
cons_sft <- consensus_SFT_fit(b6_cast_data, setLabels = c("B6", "CAST"),
                              cor_method = "pearson")

```

```{r}
#| label: cons_sft_plot
#| warning: false
#| message: false
cons_sft$plot
#cons_sft$power

```

```{r}
#| label: get_consensus_network
#| warning: false
#| message: false
#| results: hide

consensus <- consensus_modules(b6_cast_data, 
                               metadata = rbind(b6_datTraits_alt , cast_datTraits_alt),
                               power = cons_sft$power, 
                               net_type = "signed",
                               cor_method = "pearson")


```


Module preservation:

```{r}
#| label: module_preservation
#| message: false
#| warning: false
#| results: hide
#| eval: false


pres <- module_preservation(
  b6_cast_data,
  #metadata = rbind(b6_datTraits_alt , cast_datTraits_alt),
  ref_net = net_b6,
  test_net = net_cast,
  algorithm = "netrep",
  nPerm = 1000,
  nThreads = 1
)



```


# Differential gene expression analysis using maSigPro

```{r masigpro_setup}
#| eval: false
library(maSigPro)
# Similar to Deseq, I am converting to counts
# The recommended analysis to deal with RNA-Seq data is the GLM with negative.binomial
# family. θ must be specified and it can be computed by using available methods as edgeR
# ((Robinson et al., 2010)). The application of maSigPro with several values of θ to the same
# datasets did not reveal significant differences in gene selection. Taking this into consideration
# we have put by default θ = 10 for being an average value. Moreover we give to the user the
# option of applying whatever exponential family to explore other possibilities.
# Data must be normalized before the application of maSigPro as it is not integrated any
# normalized method
# data: Gene by samples
b6_data <- round(assay(b6_dds_all_norm) )
b6_data <- b6_data[all_genes_palate$gene_id,,drop=F]
b6_design_data <- b6_coldata |> 
  as_tibble( rownames = "unique_sampleid") |> 
  left_join( b6_samples |> 
               as_tibble( rownames = "sample") |> 
               select(unique_sampleid, sample) |> 
               left_join(
                 sample_annot |> 
                   select(sample, LB_stage_binned)
               ) |> 
               select(unique_sampleid, LB_stage_binned) |> 
               distinct()
             ) |> 
  filter( LB_stage_binned != "exclude") |> 
  mutate(
    ind = as.numeric(ind),
    AP_domain_value = 1,
    Gest_stage = case_when(
            Gest_stage == "E12.5"~12.5,
            Gest_stage == "E13.5"~13.5,
            Gest_stage == "E14.5"~14.5,
            Gest_stage == "E15.5"~15.5,
          ),
    # I am doing the replicates as below to match the description in the user guide that says:" Replicates column is an index column that indicates the replicated arrays: all arrays belonging to the same experimental condition must be given the same number."
    Replicate = case_when(
      Gest_stage ==12.5 & AP_domain =="MAX"~1,
      Gest_stage ==13.5 & AP_domain =="MAX"~2,
      Gest_stage ==14.5 & AP_domain =="MAX"~3,
      Gest_stage ==15.5 & AP_domain =="MAX"~4,
      Gest_stage ==12.5 & AP_domain =="PM"~5,
      Gest_stage ==13.5 & AP_domain =="PM"~6,
      Gest_stage ==14.5 & AP_domain =="PM"~7,
      Gest_stage ==15.5 & AP_domain =="PM"~8,
      Gest_stage ==12.5 & AP_domain =="POST"~9,
      Gest_stage ==13.5 & AP_domain =="POST"~10,
      Gest_stage ==14.5 & AP_domain =="POST"~11,
      Gest_stage ==15.5 & AP_domain =="POST"~12
      )
    ) |> 
  pivot_wider( id_cols = c("unique_sampleid","Gest_stage","Replicate"), names_from= "AP_domain", values_from="AP_domain_value") |> 
  mutate(
    MAX = ifelse(is.na(MAX),0, MAX),
    PM = ifelse(is.na(PM),0, PM),
    POST = ifelse(is.na(POST),0, POST)
  ) |> 
  mutate( Time = Gest_stage) |> 
  arrange(Time,Replicate) |> 
  column_to_rownames("unique_sampleid")

b6_design <- make.design.matrix(b6_design_data[,c("Time","Replicate","MAX","PM","POST")], degree = 3, time.col = 1, group.cols = c(3:5), repl.col = 2)

#b6_design$groups.vector
fit <- p.vector(b6_data, b6_design, counts = TRUE)
tstep <- T.fit(fit)
get<-get.siggenes(tstep, vars="all")
library(mclust)
cluster_genes <- see.genes(get$sig.genes, 
                           k.mclust = TRUE, 
                           cluster.method = "Mclust")


unique(cluster_genes$cut)
```









