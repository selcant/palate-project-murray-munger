---
title: "Investigating strain and developmental stage effects"
author: "Selcan Aydin"
date: "`r Sys.Date()`"
format: 
  html:
      embed-resources: true
      standalone: true
include-in-header:
  - text: |
      <style>
      .panel-tabset > .nav-tabs,
      .panel-tabset > .tab-content {
        border: none;
      }
      </style>
code-fold: true
toc: true
toc-depth: 5
toc-expand: true
editor: 
  markdown: 
    wrap: sentence
comments:
  hypothesis: 
    theme: clean
---

```{r setup}
#| message: false
#| warning: false

knitr::opts_chunk$set(message = NA, warning = NA)
# load packages
suppressPackageStartupMessages(library(tidyverse))

library(pheatmap)
library(plotly)
library(GGally)
library(ggpubr)
library(ggplot2)
library(corrplot)
library(simplifyEnrichment)

library(DESeq2)
library(DEGreport)
library(gprofiler2)
set_base_url("https://biit.cs.ut.ee/gprofiler_archive3/e108_eg55_p17/")
library(BioNERO)
set.seed(123) # for reproducibility
# library(WGCNA)

library(DT)

library(here)

select <- dplyr::select # I am adding this explicitly
rename <- dplyr::rename # I am adding this explicitly
filter <- dplyr::filter # I am adding this explicitly
summarize <- dplyr::summarize # I am adding this explicitly

# functions
create_dt <- function(x){
  DT::datatable(x,
                extensions = 'Buttons',
                rownames = FALSE, 
                filter="top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel'),
                               pageLength = 5, 
                               scrollX= TRUE
                               ))
  
}

# reading in the sample details
sample_details <- read_csv("/projects/munger-lab/projects/palate-project-murray-munger/samplesheet.csv") 

# domain colors
domain_colors <- c(PM=rgb(252,206,93, maxColorValue = 255), 
                   MAX=rgb(163,82,157, maxColorValue = 255), 
                   POST=rgb(158,156,201, maxColorValue = 255)
                   )

# strain colors
strain_colors <- c( B6 = "#555555", 
                    CAST = "#009E73",
                    DO = rgb(163,82,157, maxColorValue = 255))




```

```{r load_data_emase}
#| message: false
#| warning: false

# loading the count data
load("/projects/munger-lab/projects/palate-project-murray-munger/read_mapping/palate_gbrs_emase_counts_v4.RData") # raw_expr_mat, expr_mat_do, expr_mat_nondo 
expr_mat <- expr_mat_nondo
contam_samples <- c("B6_12.5_PM_1","B6_13.5_POST_3", "CAST_14.5_MAX_7", "B6_13.5_MAX_3")
expr_mat <- expr_mat[ ,!colnames(expr_mat) %in% contam_samples]
do_expr_mat <- expr_mat_do
remove_samples <- c("DO_13.5_MAX_6", "DO_13.5_MAX_14", "DO_13.5_MAX_14_2",
                    "DO_12.5_MAX_1" , "DO_12.5_MAX_2" ,"DO_13.5_MAX_97", "DO_13.5_MAX_96") # 96 & 97 are also 12.5 samples
do_expr_mat <- do_expr_mat[ ,!colnames(do_expr_mat) %in% remove_samples]

expr_mat_all <- cbind( expr_mat[intersect(rownames(expr_mat),rownames(do_expr_mat)),,drop=F],
                       do_expr_mat[intersect(rownames(expr_mat),rownames(do_expr_mat)),,drop=F])
rm(expr_mat_do, expr_mat_nondo)

# Get v105 annotations from biomart
all.genes_v105 <- read_tsv(here("_data","ENSMUSGid_to_symbol_v105.txt"),
                           col_names = c("gene_id","symbol","gene_biotype","chromosome","start","end"), skip =1) |>  
  mutate(midpoint = (start+end)/2)

all_genes_palate <- all.genes_v105 %>%
  filter(gene_id %in% rownames(raw_expr_mat))

all_genes_palate_filtered <- all.genes_v105 %>%
  filter(gene_id %in% rownames(expr_mat_all))

# sample annotations
sample_annot <- sample_details %>% 
  #as_tibble( rownames = "sample") |> 
  filter( !sample %in% contam_samples & sample %in% colnames(expr_mat)) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure, L_R_palate) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) |> 
  mutate( LB_stage_binned = case_when(
    ( LB_stage < 12.25 )~"exclude",
    (between(LB_stage, 13.25, 13.5))~"exclude",
    (between(LB_stage, 12.25,12.75))~"1",
    (between(LB_stage, 13.5, 14))~"2",
    (between(LB_stage, 14.25, 14.75))~"3",
    (between(LB_stage, 15.1, 15.6))~"4"
  )) |> 
  mutate( LB_stage_binned = as_factor(LB_stage_binned)) |> 
  separate( L_R_palate, into = c("temp","Palate_ori" ), sep = "_") |> 
  select(-temp) |> 
  mutate( Palate_ori = ifelse( Palate_ori == "L", "Left","Right")) 
  

sample_annot_all <- sample_details %>% 
  #as_tibble( rownames = "sample") |> 
  filter( !sample %in% contam_samples & sample %in% colnames(expr_mat_all)) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure,L_R_palate) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) |> 
  separate( L_R_palate, into = c("temp","Palate_ori" ), sep = "_") |> 
  select(-temp) |> 
  mutate( Palate_ori = ifelse( Palate_ori == "L", "Left","Right")) |> 
  mutate( LB_stage_binned = case_when(
    ( LB_stage < 12.25 )~"exclude",
    (between(LB_stage, 13.25, 13.5))~"exclude",
    (between(LB_stage, 12.25,12.75))~"1",
    (between(LB_stage, 13.5, 14))~"2",
    (between(LB_stage, 14.25, 14.75))~"3",
    (between(LB_stage, 15.1, 15.6))~"4"
  )) 

# Genes from Ian:
pheno_gene_list <- readxl::read_xlsx(here("_data","Supp6_BoneGeneList.xlsx")) |> 
  select( symbol = gene_name) |> 
  distinct() |> 
  mutate(type = "pheno", type_long = "bone phenotype gene list (Sabik et al 2020, Table S6)")

skeletal_gene_table <- readxl::read_xlsx(here("_data","Skeletal_stem_progenitor_markers.xlsx")) |> 
  dplyr::rename("symbol" = "gene") |> 
  mutate(type = "MSC", type_long = "MSC/skeletal progenitor markers")

figure_genes <- c(MSC =c("Axin2","Gli1","Meis2","Lepr","Prrx1"),
           skeletal = c("Sox9","Runx2","Sp7","Nfatc1","Bcl11b","Msx2","Msx1","Egr1","Egr2"),
           osteoclast = c("Spi1","Tnfsf11","Tnfrsf11","PParg","Fos","Junb","Csf1","Csf1r","Ostf1",
                          "Acp5","Mmp9","Ctsk","Timp1","Atp6v0d2","Adgre1","Sfrp4","Dcstamp","Ocstamp","Htra1","Tcirg1","Itgb3","Gnptab"),
           osteoblast = c("Alpl","Ibsp","Phospho1","Vdr","Sparc","Panx3","Enpp1","Bglap","Bglap2","Clecl11a","Sost","Dmp1","Col1a1","Col1a2","Bgn","Dcn","Thbs2")
           
           ) |> 
  as_tibble(rownames = "type" ) |> 
  rename( symbol = value  ) |> 
  mutate(type = gsub("[0-9]","",type)) |> 
  mutate( type_long = case_when(type =="MSC"~"MSC/skeletal progenitor markers",
                                type =="skeletal"~"Skeletal speciation markers",
                                type =="osteoclast"~"Osteoclast markers",
                                type =="osteoblast"~"osteoblast/osteocyte markers"
                                )) 

morpho_genes <- readxl::read_xlsx(path = here("_data","abnormal craniofacial morphology-MGIBatchReport.xlsx")) |> 
  select(symbol = Symbol, mgi_id = `MGI Gene/Marker ID`, gene_biotype = `Feature Type`) 

# add gene names to MGI ids for genes
# checked the overlap
# length(intersect(mgi_id_annots$symbol, all_genes_palate$symbol)) # 16958/17146
# most of the missing ones are RPXX-YY genes or Gms
mgi_id_annots <- read_delim( file = here("_data","MRK_List1.rpt"),
                             #MGI Marker Accession ID	Chromosome	cM Position	Genome Coordinate Start	Genome Coordinate End	Genome Strand	Marker Symbol	Status	Marker Name	Marker Type	Feature Types (|-delimted)	Marker Synonyms (|-delimited)
                             col_names = c("mgi_id",
                                           "chromosome",
                                           "pos_cM",
                                           "start",
                                           "end",
                                           "strand",
                                           "symbol",
                                           "status",
                                           "marker_name",
                                           "marker_type",
                                           "feature_types",
                                           "marker_synms"), skip = 1) 

# getting the gene list for mammalian phenotypes
mp_genes <- read_delim( file = here("_data","MGI_PhenoGenoMP.rpt"),
                        # Allelic Composition	Allele Symbol(s)	Genetic Background	Mammalian Phenotype ID	PubMed ID	MGI Marker Accession ID (comma-delimited)
                        col_names = c("allelic_comp",
                                      "allele_symbol",
                                      "genetic_background",
                                      "mp_id",
                                      "pubmed_id",
                                      "mgi_id")) |> 
  select(mp_id, mgi_id) |> 
  distinct() |> 
  separate_longer_delim( mgi_id, delim = "|") |> 
  left_join(mgi_id_annots |> 
              select(mgi_id, symbol)) 
# add mammalian phenotype definitions
mp_defs <- read_delim( file = here("_data","VOC_MammalianPhenotype.rpt"),
                       col_names = c("mp_id","term_name","term_details")) 



genes <- full_join( figure_genes, skeletal_gene_table ) |> 
  #full_join( pheno_gene_list) |> 
  left_join(all_genes_palate)
# 
# genes |> 
#   group_by(symbol) |> 
#   mutate(n = n()) |> 
#   filter(n > 1) |> 
#   arrange(symbol)

tfs <- read_tsv(file = here("_data/search_result_from_tfcheckpoint.txt")) |> 
  filter( !is.na(Gene_Name)) |> 
  select( symbol = Gene_symbol) |> 
  mutate( symbol = tools::toTitleCase(tolower(symbol)) ) |> 
  distinct() |> 
  left_join( all_genes_palate)

```

This notebook is analyzing the palate gene expression from different genetic backgrounds, AP domains obtained at various gestational stages.
I divided the analyses over two notebooks since the results were too large to fit into one.

This first notebook includes:

-   Principal component analysis using the filtered and normalized gene expression counts from DO, B6 and CAST mice to look at sources of variation.
-   Weighted gene coexpression network analysis using BioNERO package.
-   Consensus gene regulatory network inference with GENIE3, ARACNE and CLR using BioNERO package.
-   Use of MEFISTO to identify factors that change gradually along developmental time and other sources of variation that are independent of time.

Differential gene expression analysis is in the second notebook called `Strain_effects_degenes_GRCm39.html`.
The genetic characterization of gene expression and developmental phenotypes using the DO strains can be found in `Palate_qtl_mapping.html` notebook.

# Principal component analysis

```{r pca_b6_cast_do}
#| message: false
#| warning: false

# I am going to collapse replicates + normalize the full data set then subset per strain instead of subsetting and processing after
all_samples <- sample_annot_all |> 
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori,LB_stage_binned) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
cts_all <- round(raw_expr_mat[, rownames(all_samples),drop=F])
dds_all <- DESeqDataSetFromMatrix( countData = cts_all,
                                  colData = all_samples,
                                  design = ~1)
dds_all <- collapseReplicates(dds_all, dds_all$unique_sampleid)
dds_all_norm <- vst(dds_all)

#expr_mat_all_final <- assay( dds_all_norm)[rownames(expr_mat_all),,drop=F]
pca <- prcomp( t( log1p( assay( dds_all_norm)[rownames(expr_mat_all),,drop=F])), center = T, scale = F)
pca_df <- as_tibble(pca$x, rownames = "sample") %>% 
  #left_join(sample_annot_all)
  left_join( colData(dds_all_norm) |> 
               as_tibble(rownames = "sample"))
var_explained <- (pca$sdev^2 / sum(pca$sdev^2))

```

Raw data was processed as follows:

-   Genes with a median transcript per million (TPM) lower than 0.5 were filtered while samples were grouped by gestational stage.
    The grouping is necessary because there are uniquely expressed genes in each stage.

-   The replicates in the data due to re-sequencing are merged using the `DESeq2::collapseReplicates()` function.

-   Counts were normalized using variance stablizing transformation as implemented in DESeq2::vst() function.

In the final data set we have `r formatC(nrow(assay( dds_all_norm)[rownames(expr_mat_all),,drop=F]), big.mark=",")` genes expressed across `r ncol(assay( dds_all_norm))` samples.

Brief summary of PCA results:

-   First principal component (PC1) groups samples by developmental time.

-   PC2 groups samples by strain background.

-   PC3 and PC4 groups samples by domain with PC4 specifically separating the POST domain from the others.

-   PC5 is highlighting outlier samples that are mostly DO.
    I included a follow up analysis on these samples in that tab.

-   PC6 groups samples based on sex of the animals.

```{r pca_ora}
#| cache: true
#| message: false
#| warning: false

# pc drivers
pc1_drivers <- pca$rotation[,"PC1", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC1) >= quantile(abs(PC1), 0.95))

pc2_drivers <- pca$rotation[,"PC2", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC2) >= quantile(abs(PC2), 0.95))

pc3_drivers <- pca$rotation[,"PC3", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC3) >= quantile(abs(PC3), 0.95))

pc4_drivers <- pca$rotation[,"PC4", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC4) >= quantile(abs(PC4), 0.95))

pc5_drivers <- pca$rotation[,"PC5", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC5) >= quantile(abs(PC5), 0.95))

pc6_drivers <- pca$rotation[,"PC6", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC6) >= quantile(abs(PC6), 0.95))

pc7_drivers <- pca$rotation[,"PC7", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC7) >= quantile(abs(PC7), 0.95))


# ORA with pc drivers 1-5
# background


g.pc1 <- gost(
  query = pc1_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate_filtered$symbol,
  evcodes = TRUE
)
g.pc1$result <- g.pc1$result %>% filter(term_size < 660)

g.pc2 <- gost(
  query = pc2_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate_filtered$symbol,
  evcodes = TRUE
)
g.pc2$result <- g.pc2$result %>% filter(term_size < 660)

g.pc3 <- gost(
  query = pc3_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate_filtered$symbol,
  evcodes = TRUE
)
if(length(g.pc3$result) >1) g.pc3$result <- g.pc3$result %>% filter(term_size < 660)

g.pc4 <- gost(
  query = pc4_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate_filtered$symbol,
  evcodes = TRUE
)
if(length(g.pc4$result) >1) g.pc4$result <- g.pc4$result %>% filter(term_size < 660)

g.pc5 <- gost(
  query = pc5_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate_filtered$symbol,
  evcodes = TRUE,
  correction_method = "fdr"
)
if(length(g.pc5$result) >1) g.pc5$result <- g.pc5$result %>% filter(term_size < 660)

g.pc6 <- gost(
  query = pc6_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate_filtered$symbol,
  evcodes = TRUE,
  correction_method = "fdr"
)
if(length(g.pc6$result) >1) g.pc6$result <- g.pc6$result %>% filter(term_size < 660)

```

::: {#PCs .panel-tabset .nav-pills}
## Looking at first 10 PCs

By strain:

```{r first_five_pcs_emase_strain}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  #left_join(sample_annot_all) %>%
  left_join( colData(dds_all_norm) |> 
               as_tibble(rownames = "sample")) |> 
  ggpairs(
    columns = 2:11, progress = FALSE, ggplot2::aes(color = strain, shape =strain),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  scale_color_manual( values = strain_colors)+
  scale_fill_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond", DO="square"))+
  # color_palette("npg")+
  # fill_palette("npg")+
  theme(legend.position = "right")

```

By gestational stage:

```{r first_five_pcs_emase_gest}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  #left_join(sample_annot_all) %>%
  left_join( colData(dds_all_norm) |> 
               as_tibble(rownames = "sample")) |> 
  ggpairs(
    columns = 2:11, progress = FALSE, ggplot2::aes(shape = strain, color =Gest_stage),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  # scale_color_manual( values = strain_colors)+
  # scale_fill_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  scale_color_viridis_d()+
  scale_fill_viridis_d()+
  theme(legend.position = "right")

```

By sex:

```{r first_five_pcs_emase_sex}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  #left_join(sample_annot_all) %>%
  left_join( colData(dds_all_norm) |> 
               as_tibble(rownames = "sample")) |> 
  ggpairs(
    columns = 2:11, progress = FALSE, ggplot2::aes(shape = strain, color =sex),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  # scale_color_manual( values = strain_colors)+
  # scale_fill_manual( values = strain_colors)+
  # scale_color_viridis_d()+
  # scale_fill_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  color_palette("npg")+
  fill_palette("npg")+
  theme(legend.position = "right")

```

Variation explained:

```{r scree_plot_emase}
#| message: false
#| warning: false
#| fig-width: 5
#| fig-height: 4

tibble(var =  var_explained[1:10]* 100, PC = paste0("PC", seq(1:10))) %>%
  arrange(desc(var)) %>%
  mutate(label = factor(PC, levels = PC)) %>%
  ggplot(aes(x = label, y = var)) +
  geom_col() +
  xlab("Principal Component") +
  ylab("% Variation explained") +
  theme_pubclean(base_size = 14)+
  ylim(0,25)


```

## PC1, PC2 and PC3

```{r pc123_3dplot}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

fig <- plot_ly(pca_df, 
               x = ~PC1, 
               y = ~PC2, 
               z = ~PC3,
               symbol = ~strain,
               symbols = c("circle","diamond","square"),
               text = ~sample,
               color = ~LB_stage,
               #colors = scale_color_viridis_c(limits = c(12,16)),
               reversescale = TRUE,
               mode = "markers",
               type = "scatter3d"
               #marker = list(color = ~LB_stage, colorscale = 'Viridis', reversescale = TRUE, showscale = T)
)
fig <- fig %>% 
  layout(scene = list(xaxis = list(title = paste0("PC1 (",100*round(var_explained[1],2),"%)")),
                                   yaxis = list(title = paste0("PC2 (",100*round(var_explained[2],2),"%)")),
                                   zaxis = list(title = paste0("PC3 (",100*round(var_explained[3],2),"%)")))
)

fig

```

```{r pc123_3dplot_dom}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

fig <- plot_ly(pca_df, 
               x = ~PC1, 
               y = ~PC2, 
               z = ~PC3,
               color = ~AP_domain,
               symbol = ~strain,
               symbols = c("circle","diamond","square"),
               text = ~sample,
               colors = c(domain_colors),
               mode = "markers",
               type = "scatter3d"
)
fig <- fig %>% 
  layout(scene = list(xaxis = list(title = paste0("PC1 (",100*round(var_explained[1],2),"%)")),
                                   yaxis = list(title = paste0("PC2 (",100*round(var_explained[2],2),"%)")),
                                   zaxis = list(title = paste0("PC3 (",100*round(var_explained[3],2),"%)")))
)

fig

```

## PC1 groups samples by developmental time

```{r pc1_pc2_emase}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC1, 
       y = PC2,
       col = Gest_stage,
       shape = strain,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  #scale_color_manual( values = strain_colors)+
  scale_color_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  ylab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  theme(legend.position = "right")+
  labs(shape = "strain",
       col = "Gestational\nstage")


ggplotly(pca_plot, tooltip = c("label"))

```

```{r pc1_pc2_emase_lb}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC1, 
       y = PC2,
       shape = strain,
       #shape = Gest_stage,
       col = LB_stage,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  scale_color_viridis_c(limits = c(12,16))+
  #scale_color_manual(values=strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  ylab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  theme(legend.position = "right")+
  labs(color = "Limb bud\nstage",
       shape = "Strain")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC1 driver genes:

```{r pc1_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc1)

```

```{r pc1_ora_table}
#| message: false
#| warning: false


g.pc1$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%  # intersecion: adding the list of genes identified as overlapping with each category
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC1 driver genes:

```{r pc1_gene_table}
#| message: false
#| warning: false


pc1_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(gene_id, chromosome)
  ) %>% 
  arrange(desc(abs(PC1))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC2 groups samples by strain

```{r pc2_pc1_strain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC2, 
       y = PC1,
       col = strain,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  scale_color_viridis_d()+
  #color_palette("npg")+
  scale_color_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  ylab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC2 driver genes:

```{r pc2_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc2, capped = F)

```

```{r pc2_ora_table}

g.pc2$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC2 driver genes:

```{r pc2_gene_table}
#| message: false
#| warning: false


pc2_drivers %>% 
    left_join(
    all_genes_palate %>% 
      select(gene_id, chromosome)
  ) %>% 
  arrange(desc(abs(PC2))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC3 and PC4 group samples by domain

```{r pc4_pc3_domain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC3, 
       y = PC4,
       col = AP_domain,
       shape = strain,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #scale_color_viridis_c(limits = c(12,16))+
  scale_color_manual(values = domain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC4 (",100*round(var_explained[4],2),"%)"))+
  xlab(paste0("PC3 (",100*round(var_explained[3],2),"%)"))+
  theme(legend.position = "right")+
  labs(color = "AP domain",
       shape = "Strain")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC3 driver genes:

```{r pc3_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc3, capped = T)

```

```{r pc3_ora_table}
#| eval: true
g.pc3$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC3 driver genes:

```{r pc3_gene_table}
#| message: false
#| warning: false


pc3_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(gene_id, chromosome)
  ) %>% 
  arrange(desc(abs(PC3))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

```{r pc1_pc4_domain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC4, 
       y = PC1,
       col = AP_domain,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  scale_color_manual( values = domain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC4 (",100*round(var_explained[4],2),"%)"))+
  ylab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC4 driver genes:

```{r pc4_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc4, capped = T)

```

```{r pc4_ora_table}

g.pc4$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC4 driver genes:

```{r pc4_gene_table}
#| message: false
#| warning: false


pc4_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(gene_id, chromosome)
  ) %>% 
  arrange(desc(abs(PC4))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC5 identifies outliers

```{r pc5_pc6}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>%
  filter( !is.na(sex)) %>%
  ggplot()+
  aes( x = PC1,
       y = PC5,
       col = LB_stage,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  scale_color_viridis_c(limits = c(12,16))+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC5 (",100*round(var_explained[5],2),"%)"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

Table with the full list of PC5 driver genes:

```{r pc56_gene_table}
#| message: false
#| warning: false


pc5_drivers %>% 
  mutate(PC = "PC5") |> 
  dplyr::rename( "value" = "PC5") |> 
  # rbind(
  #   pc6_drivers |> 
  #     mutate(PC = "PC6") |> 
  #     dplyr::rename("value" = "PC6")
  # ) |> 
  left_join(
    all_genes_palate %>% 
      select(gene_id, chromosome)
  ) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

```{r}
#| label: pc5_outliers

# out_samples <- c("DO_13.5_MAX_16", 
#                        "DO_13.5_MAX_38",
#                        "DO_13.5_MAX_46",
#                        "DO_13.5_MAX_47",
#                        "DO_13.5_MAX_80",
#                        "DO_13.5_MAX_83",
#                        "DO_13.5_MAX_89")

out_samples <- pca_df |> 
  filter( PC5 > 2) 
pca_plot <- pca_df %>%
  filter( !is.na(sex)) %>%
  mutate( outlier = case_when( (sample %in% out_samples$sample)~"Outlier",
                               (!sample %in% out_samples$sample)~"Not an outlier")
          )|> 
  ggplot()+
  aes( x = PC1,
       y = PC5,
       col = outlier,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  #scale_color_viridis_c(limits = c(12,16))+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC5 (",100*round(var_explained[5],2),"%)"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

So the outlier samples are:

```{r}

out_samples |> 
  select(sample, PC5) |> 
  mutate(PC5  = round(PC5,2)) |> 
  create_dt()
```

Let's look through gene expression values and see for which genes these samples are also outliers.
First method I will use is to simply ask if the expression for the `r nrow(out_samples)` outlier samples are at the edge of the normal distribution.
I will convert the expression values for each gene to Z-scores and than ask where the outlier samples are falling within the distribution.
Below is the list of genes where the expression is an outlier for all the samples ( abs(z-score) \> 2) with PC5 values added for the genes that were also identified as PC5 drivers.

```{r}
#| label: outlier_follow_up_zscores
#| warning: false
#| message: false

expr_zscores <- scale( t(assay( dds_all_norm)[all_genes_palate_filtered$gene_id,,drop=F]))

out_genes_zscore <- expr_zscores |> 
  as_tibble(rownames = "sample") |> 
  filter( sample %in% out_samples$sample) |> 
  select(-sample) |> 
  summarise(across(everything(), ~ all(. < -2 | . > 2))) |> 
  pivot_longer(cols =  everything(),names_to = "gene_id", values_to = "is_outlier") |> 
  filter(is_outlier == T)

out_genes_zscore |> 
  left_join( all_genes_palate_filtered |> select(gene_id, symbol, chromosome, gene_biotype)) |> 
  left_join( pc5_drivers) |> 
  mutate(PC5 = round(PC5,2)) |> 
  select(-is_outlier) |> 
  create_dt()

```

Let's plot some of them to see what they look like, I am choosing the ones with the highest/lowest z-scores:

```{r}
#| label: plot_outliers
#| eval: true
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 10

med_zscores <- expr_zscores[ out_samples$sample, out_genes_zscore$gene_id] |> 
  as_tibble(rownames = "sample") |> 
  pivot_longer( cols = -sample, names_to = "gene_id", values_to = "zscore") |> 
  group_by( gene_id) |> 
  summarize( zscore = median(zscore)) 

top_out_genes <-  c(slice_min(med_zscores, zscore , n = 5)$gene_id,
                    slice_max(med_zscores, zscore , n = 6)$gene_id)


log1p(t(assay(dds_all_norm)[top_out_genes,])) |> 
  as_tibble( rownames = "sample") |> 
  pivot_longer( cols = -sample, values_to = "expr",names_to= "gene_id") |> 
  left_join( colData(dds_all_norm) |> as_tibble(rownames = "sample")) |> 
  left_join( all_genes_palate_filtered |> select(gene_id, symbol)) |> 
  filter(!is.na(symbol)) |> 
  mutate( out = ifelse( sample %in% out_samples$sample, "outlier","not an outlier")) |> 
  ggplot()+
  aes(
    x = LB_stage,
    y = expr,
    col = AP_domain
  )+
  geom_point( aes(shape = out))+
  geom_smooth()+
  theme_pubclean(base_size = 18)+
  facet_wrap(~symbol, ncol= 5, scales = "free")+
  scale_color_manual(values = domain_colors)+
  xlab("LB stage")+
  ylab("Log tansformed gene expression counts")
  

```

Below are over-representated biological processes and pathways:

```{r}
#| label: ora_outliers
#| eval: true
#| warning: false
#| message: false
#| cache: true

g.outlier <- gost(
  query = (out_genes_zscore |> left_join( all_genes_palate_filtered |> select(gene_id, symbol)))$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate_filtered$symbol,
  evcodes = TRUE
)
g.outlier$result <- g.outlier$result %>% filter(term_size < 660)


```

```{r}
#| label: ora_outliers_table
#| eval: true
#| warning: false
#| message: false
g.outlier$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

## PC6 groups samples by sex

```{r pc6_pc1}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  filter( !is.na(sex)) %>% 
  ggplot()+
  aes( x = PC1, 
       y = PC6,
       col = sex,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  color_palette("npg")+
  #scale_color_viridis_d()+
 scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC6 (",100*round(var_explained[6],2),"%)"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

Table with the full list of PC6 driver genes:

```{r pc6_gene_table}
#| message: false
#| warning: false


pc6_drivers %>% 
  mutate(PC = "PC6") |> 
  dplyr::rename("value" = "PC6") |> 
  left_join(
    all_genes_palate %>% 
      select(gene_id, chromosome)
  ) %>% 
  # rbind(
  #   pc7_drivers |>
  #     mutate(PC = "PC7") |>
  #     dplyr::rename("value" = "PC7") |> 
  #     left_join(
  #       all_genes_palate %>% 
  #         select(symbol, chromosome))
  # ) |>
  #arrange(desc(abs(PC7))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```
:::

# Weighted gene co-expression network analysis (WGCNA)

```{r}
#| label: wgcna_prep_all
#| warning: false 
#| message: false

# I am going to collapse replicates + normalize the full data set then subset per strain instead of subsetting and processing after
all_samples <- sample_annot_all |> 
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
cts_all <- round(raw_expr_mat[, rownames(all_samples),drop=F])
dds_all <- DESeqDataSetFromMatrix( countData = cts_all,
                                  colData = all_samples,
                                  design = ~1)
dds_all <- collapseReplicates(dds_all, dds_all$unique_sampleid)
dds_all_norm <- vst(dds_all)

```

```{r}
#| label: wgcna_prep_b6
#| warning: false
#| message: false

b6_samples <- sample_annot %>%
  filter(strain %in% c("B6")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
# b6_cts_all <- round(raw_expr_mat[,rownames(b6_samples), drop = F])
# b6_dds_all <- DESeqDataSetFromMatrix( countData = b6_cts_all,
#                                   colData = b6_samples,
#                                   design = ~1)
# b6_dds_all <- collapseReplicates(b6_dds_all, b6_dds_all$unique_sampleid)
# b6_dds_all_norm <- vst(b6_dds_all)
# b6_datExpr <- t(assay(b6_dds_all_norm))
b6_coldata <- colData(dds_all) |> 
  as_tibble() |> 
  filter( strain == "B6") |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage, Palate_ori) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")
# b6_gsg <- goodSamplesGenes(b6_datExpr)
# summary(b6_gsg)
b6_datTraits <- colData(dds_all) |> 
  as_tibble() |> 
  filter( strain == "B6") |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori,strain) %>%
  mutate( strain = ifelse( strain == "B6",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
b6_datTraits_alt <- colData(dds_all) |> 
  as_tibble() |> 
  filter( strain == "B6") |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori, strain) %>%
  column_to_rownames("unique_sampleid")

# 2. Following Ian's analysis to get most variable genes
B6rv_wpn <- rowVars(assay(dds_all_norm)[, rownames(b6_coldata),drop=F])
B6q90_wpn <- quantile( rowVars(assay(dds_all_norm)[, rownames(b6_coldata),drop=F]), .9)  # <= changed to 95 quantile to reduce dataset
b6_datExpr <- t(assay(dds_all_norm)[ B6rv_wpn > B6q90_wpn, rownames(b6_coldata)])
b6_expr <- SummarizedExperiment(assays=list(counts=t(log1p(b6_datExpr))),
                                                 colData=b6_datTraits_alt)


```

```{r}
#| message: false
#| warning: false
#| label: wgcna_prep_cast
#| results: hide

# Let's prep the cast samples for later use here too
cast_samples <- sample_annot %>%
  filter(strain %in% c("CAST")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
# cast_cts_all <- round(raw_expr_mat[,rownames(cast_samples), drop = F])
# cast_dds_all <- DESeqDataSetFromMatrix( countData = cast_cts_all,
#                                   colData = cast_samples,
#                                   design = ~1)
# cast_dds_all <- collapseReplicates(cast_dds_all, cast_dds_all$unique_sampleid)
# cast_dds_all_norm <- vst(cast_dds_all)
# cast_datExpr <- t(assay(cast_dds_all_norm))
cast_coldata <- colData(dds_all) |> 
  as_tibble() |> 
  filter( strain == "CAST") |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage,Palate_ori) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")


# cast_gsg <- goodSamplesGenes(cast_datExpr)
# summary(cast_gsg)
cast_datTraits <- colData(dds_all) |> 
  as_tibble() |> 
  filter( strain == "CAST") |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage,Palate_ori, strain) %>%
  mutate( strain = ifelse( strain == "CAST",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
cast_datTraits_alt <- colData(dds_all) |> 
  as_tibble() |> 
  filter( strain == "CAST") |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori,strain) %>%
  column_to_rownames("unique_sampleid")
# # Following Ian's analysis to get most variable genes
CASTrv_wpn <- rowVars(assay(dds_all_norm)[, rownames(cast_coldata),drop=F])
# CASTq75_wpn <- quantile( rowVars(assay(cast_dds_all_norm)), .75)  # <= original
CASTq90_wpn <- quantile( rowVars(assay(dds_all_norm)[, rownames(cast_coldata),drop=F]), .90)  # <= changed to 95 quantile to reduce dataset
cast_datExpr <- t(assay(dds_all_norm)[ CASTrv_wpn > CASTq90_wpn,rownames(cast_coldata) ])
# # convert to summarized experiment object for later use in bionero functions
cast_expr <- SummarizedExperiment(assays=list(counts=t(cast_datExpr)),
                     colData=cast_datTraits_alt)


```

```{r}
#| message: false
#| warning: false
#| label: wgcna_prep_do
#| results: hide

# Let's prep the do samples for later use here too
do_samples <- sample_annot_all %>%
  filter(strain %in% c("DO")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
# do_cts_all <- round(raw_expr_mat[,rownames(do_samples), drop = F])
# do_dds_all <- DESeqDataSetFromMatrix( countData = do_cts_all,
#                                   colData = do_samples,
#                                   design = ~1)
# do_dds_all <- collapseReplicates(do_dds_all, do_dds_all$unique_sampleid)
# do_dds_all_norm <- vst(do_dds_all)
# cast_datExpr <- t(assay(cast_dds_all_norm))
do_coldata <- colData(dds_all) |> 
  as_tibble() |> 
  filter(strain == "DO") |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage,Palate_ori) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")

do_datTraits <- colData(dds_all) |> 
  as_tibble() |> 
  filter(strain == "DO") |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage,Palate_ori, strain) %>%
  mutate( strain = ifelse( strain == "CAST",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
do_datTraits_alt <- colData(dds_all) |> 
  as_tibble() |> 
  filter(strain == "DO") |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori,strain) %>%
  column_to_rownames("unique_sampleid")
# # Following Ian's analysis to get most variable genes
DOrv_wpn <- rowVars(assay(dds_all_norm)[,rownames(do_coldata), drop = F])
DOq90_wpn <- quantile( rowVars(assay(dds_all_norm)[,rownames(do_coldata), drop = F]), .9)  # <= changed to 95 quantile to reduce dataset
do_datExpr <- t(assay(dds_all_norm)[ DOrv_wpn > DOq90_wpn, rownames(do_coldata)])
# # convert to summarized experiment object for later use in bionero functions
do_expr <- SummarizedExperiment(assays=list(counts=t(do_datExpr)),
                     colData=do_datTraits_alt)


```

```{r}
#| label: prep_wgcna_all_three 

# Here I am subsetting the gene expression matrices to the genes that are most variable in B6 and CAST.

b6_expr_final <- b6_expr[ intersect(rownames(b6_expr), rownames(cast_expr)),,drop=F]

cast_expr_final <- cast_expr[ intersect(rownames(b6_expr), rownames(cast_expr)),,drop=F]
do_expr_final <- SummarizedExperiment(
  assays = list((assay(dds_all_norm)[ intersect(rownames(b6_expr), rownames(cast_expr)),rownames(do_coldata),drop=F ])),
  colData = do_datTraits_alt)

wgcna_genes <- all_genes_palate |> 
  filter( gene_id %in% intersect(rownames(b6_expr), rownames(cast_expr)))
```

Based on previous analyses, we settled on running WGCNA:

-   Using the intersection of genes between top 10% variable genes in B6 and CAST strains (n = `r formatC(nrow(b6_expr_final),big.mark=",")`).

-   Running WGCNA separately for each background, then comparing the modules.

Note that I start with the unfiltered, raw data expression for all the samples (B6, CAST and DO) then I collapse the replicates and normalize using vst.
Next, I subset and filter the B6 and CAST strain samples for the top 10% most variable genes.
Finally, I take the intersection of the filtered genes between the B6 and CAST strains which leads to `r formatC( nrow(wgcna_genes), big.mark = ",")` genes in total and I subset all three expression data sets including the DO data using this final list of genes.
Using the same set of genes allows us to compare modules and look at module preservation across the WGCNA networks identified for each strain.

:::::::::::: {#WGCNA_results .panel-tabset .nav-pills}
## B6

```{r}
#| warning: false
#| message: false
#| label: choose_sft_power_b6
#| results: hide

# Choose a set of soft-thresholding powers
b6_sft <- SFT_fit(b6_expr_final, 
                  net_type = "signed",  
                  cor_method = "pearson",
                  rsquared = 0.7 
                  )
```

```{r}
#| label: sft_power_plot_b6
#| fig-width: 12
#| fig-height: 5
b6_sft$plot 
```

```{r}
#| label: run_wgcna_b6
#| warning: false
#| message: false
#| results: hide

power_b6 <- b6_sft$power

net_b6 <- exp2gcn(
    b6_expr_final, 
    net_type = "signed", 
    #module_merging_threshold = 0.75,
    SFTpower = power_b6, 
    cor_method = "pearson"
)
# 
# plot_dendro_and_colors(net_b6)
# plot_eigengene_network(net_b6)
# plot_ngenes_per_module(net_b6)


```

Assessing module stability by re-sampling:

```{r}
#| label: module_stability_b6
#| warning: false
#| message: false
#| cache: true
#| results: hide
 
#net_b6$params$cor_method <- "bicor"
module_stability(b6_expr_final, net_b6, nRuns = 50)


```

Using `r formatC(nrow(b6_expr_final),big.mark=",")` genes and `r formatC(ncol(b6_expr_final),big.mark=",")` samples.
For gene coexpression network inference I am using the `exp2gcn` function in BioNero with the following options:

-   `net_type = "signed"` : I chose this option to get more biologically meaningful networks where the sign of the correlation is preserved and module detection focuses on positively correlated genes.

-   `cor_method = "pearson"`: I chose Pearson correlation because our data is relatively clean.

-   `SFTpower =` `r power_b6`: as the threshold for power since it is where the 0.7 R\^2 threshold is crossed the first time.

This leads to `r ncol(net_b6$MEs)` modules in total which are characterized below.
Remember the 'grey' module is a catch all module where WGCNA places the genes that cannot be assigned to any specific module.

::::: {.panel-tabset .nav-pills}
### Eigengene adjacency plot

```{r}
#| label: eigengene_network_plot_b6
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 8

# I got the code from the bionero plot_eigengene_network function's source code
mes_b6 <- net_b6$MEs[, !names(net_b6$MEs) %in% "MEgrey"]
me_correlation_b6 <- cor(mes_b6)

clusters <- hclust(as.dist(1 - me_correlation_b6), method = "average")
# Create column metadata and row metadata
coldata <- data.frame(row.names = names(mes_b6), Module = names(mes_b6))
rowdata <- data.frame(row.names = names(mes_b6), Module = names(mes_b6))

colors <- list(
        Module = setNames(gsub("ME", "", names(mes_b6)), names(mes_b6))
    )

# Plot heatmap with distances
pal <- colorRampPalette(RColorBrewer::brewer.pal(n = 7, name = "PRGn"))(100)
pheatmap(
        me_correlation_b6, name = "Correlation",
        color = pal,
        cluster_cols = clusters,
        cluster_rows = clusters,
        # clustering_distance_rows = "correlation",
        # clustering_distance_cols = "correlation",
        # clustering_method = "average",
        main = "Pairwise correlations between module eigengenes",
        legend_breaks = seq(-1, 1, 0.5),
        breaks = seq(-1, 1, 0.02),
        annotation_row = rowdata,
        annotation_col = coldata,
        legend = TRUE,
        annotation_colors = colors,
        annotation_legend = FALSE
          
    )
    

```

### Module genes

```{r}
#| label: module_genes_table_b6
#| message: false
#| warning: false

net_b6$genes_and_modules |> 
  left_join( all_genes_palate |> 
               select( Genes = gene_id, symbol, chromosome)
            ) |> 
  group_by(Modules) |> 
  arrange(Modules, symbol) |> 
  create_dt()

```

### Module eigengenes

```{r}
#| label: module_eigengenes_all_b6
#| warning: false
#| message: false
#| results: asis
#| fig-width: 16
#| fig-height: 14

module_eigenges <- net_b6$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(b6_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long <-  module_eigenges |> 
  pivot_longer( 2:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = AP_domain)+
    geom_jitter()+
    geom_smooth( aes(col = AP_domain))+
    scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 3)


```

::: {#WGCNA_module_eigengenes .panel-tabset .nav-pills}
```{r}
#| label: module_eigengene_plots_b6
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

plot_eigengene_by_module_genes <- function(mod_name, module_eigengenes_long, expr, coldata,module_genes){
    
    df <- module_eigengenes_long |> 
      filter( module == mod_name) |> 
      arrange( value) |> 
      mutate( sample = as_factor(sample))
  
    eigengene_plot <- df |> 
      ggplot()+
      aes( y = value, x= LB_stage, col = AP_domain)+
      geom_jitter()+
      geom_smooth( aes(col = AP_domain))+
      scale_color_manual( values = domain_colors)+
      theme_pubclean(base_size = 16)+
      theme( legend.position = "top")+
      xlab("LB stage")+
      ylab("Module summary eigengene")
    
    mod_genes <- module_genes |> 
      filter(Modules ==gsub("ME","",mod_name))
    
    coldata_ordered <- coldata |> 
      as_tibble(rownames = "sample") |> 
      arrange(LB_stage,AP_domain) |> 
      column_to_rownames("sample") |> 
      as.matrix()
    
    mat <- log1p(assay(expr)[mod_genes$Genes, rownames(coldata_ordered), drop = FALSE])
    
    gene_plot <- pheatmap(mat = mat,
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = coldata[,c("AP_domain","LB_stage","Palate_ori","sex")],
         annotation_colors = list( 
                    #strain = strain_colors[c("cast","CAST")],
                    AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
                    ),
         treeheight_row = 0, 
         treeheight_col = 0,
         silent = TRUE
    )
    
    ggarrange( ggarrange(eigengene_plot,NULL, nrow = 1, widths = c(1, 0.2)), 
               ggarrange( NULL, gene_plot$gtable, widths = c(0.1, 1)),
               ncol = 1, nrow = 2, heights = c(.8,1))
}

module_genes <- net_b6$genes_and_modules
module_colors <- unique(module_eigengenes_long$mod_col)
names(module_colors) <- paste0("ME",module_colors)


for(mod in names(module_colors)){
  
  cat("\n#####",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_module_genes(mod, module_eigengenes_long, b6_expr_final, b6_coldata, module_genes))
  cat("\n \n")
  
}

# a <- plot_eigengene_by_samples("MEblack")
# ggsave(a, filename = here("_figures","test.pdf"), width = 8, height = 6)

```
:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_b6
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
b6_me_trait_cor <- c()
for(i in 1:(ncol(b6_datTraits_alt)-1)){
  
  b6_me_trait_cor[[colnames(b6_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(b6_expr_final), # get just the expression
                                            metadata = b6_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_b6$MEs,
                                            #continuous_trait = is.numeric(b6_datTraits_alt[1,i]),
                                            #palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp_b6 <- reshape2::melt(b6_me_trait_cor) |> 
  select(-L1) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat_b6 <- reshape2::dcast(corandp_b6, ME ~ trait, value.var = "cor")
rownames(cormat_b6) <- cormat_b6$ME
cormat_b6$ME <- NULL
cormat_b6 <- as.matrix(cormat_b6)
cormat_b6[is.na(cormat_b6)] <- 0

pmat_b6 <- reshape2::dcast(corandp_b6, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat_b6) <- pmat_b6$ME
pmat_b6$ME <- NULL
pmat_b6[is.na(pmat_b6)] <- ""

```

```{r}
#| label: module_trait_cor_plot_b6
#| fig-width: 10
#| fig-height: 6

corrplot(corr = cormat_b6[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F],
         p.mat = as.matrix(pmat_b6[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(10,12), ylim=c(2,12), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r}
#| label: module_trait_cor_table_b6
#| warning: false
#| message: false
cormat_b6[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:9, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat_b6[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:9, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

```{r }
#| label: wgcna_module_ora_b6
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
ora_results <- c()
modules <- unique(net_b6$genes_and_modules$Modules)
for( mod in modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_b6$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = wgcna_genes$symbol,
                        evcodes = TRUE)
  ora_results[[mod]] <- g.mod
}

```

```{r }
#| label: wgcna_ora_restuls_table_b6
#| eval: true
do.call( rbind, ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```

### Hub genes

Hub genes are often identified using two different metrics: module membership (MM) (i.e., correlation of a gene to its module eigengene) and degree (i.e., sum of connection weights of a gene to all other genes in the module).
Some researchers consider the top 10% genes with the highest degree as hubs, while others consider those with MM \> 0.8.
To avoid false positives, BioNEROs algorithm combines both metrics and defines hub genes as the top 10% genes with highest degree that have MM \> 0.8.
Hubs are identigied with the function `get_hubs_gcn()` below.

```{r}
#| label: get_hub_genes_b6
#net_b6$params$cor_method <- "biweight"
hubs_b6 <- get_hubs_gcn(b6_expr_final, net_b6)

hubs_b6 |> 
  left_join( all_genes_palate |> 
               select( Gene = gene_id, symbol)) |> 
  select( Gene, Symbol = symbol, Module, kWithin) |> 
  mutate( kWithin = round(kWithin , 2)) |> 
  create_dt()

```

Below I am getting the sub-networks within each module then plotting them per module.
I am also plotting the protein-protein interaction networks within each module with communities detected in each one.
Note that some modules are really big, hence the networks are really big as well!
I am only labeling the 15 top hub genes in each network.
Some of the images look really ugly!
I can regenerate them manually, I am looping through them here so they all have the same figure settings.

```{r}
#| label: get_subnetworks_b6
#| results: hold
#| warning: false
#| message: false
#| fig-show: hide


modules <- unique(net_b6$genes_and_modules$Modules)
edges_filt_b6 <- list()
for(mod in modules){
  # Remove edges based on optimal scale-free topology fit
  edges_filtered <- get_edge_list(net_b6, module = mod, filter = TRUE)  
  edges_filt_b6[[mod]] <- edges_filtered
}

```

```{r}
#| eval: true
#| label: update_plot_network_functions
#| warning: false
#| message: false

# Can't get this to work! 
# I'm copying over to troubleshoot
# Needed to add:  stringsAsFactors = FALSE to ggnetwork()
# I also added gene_annots to change geneids to symbols in the plot + updated the plotting bits to use Symbol instead of name

library(igraph)
library(ggnetwork)
plot_gcn <- function(edgelist_gcn, net, color_by = "module", hubs = NULL,
                     show_labels = "tophubs", top_n_hubs = 5,
                     curvature = 0,
                     interactive = FALSE, dim_interactive = c(600,600),
                     gene_annots) {
    requireNamespace("intergraph", quietly=TRUE)

    if(is.null(hubs) | is.null(edgelist_gcn)) {
        stop("Arguments 'edgelist_gcn' and 'hubs' are mandatory for this network.")
    }

    # How should genes be colored?
    if(is.data.frame(color_by)) {
        gene_annotation <- color_by # color by custom annotation
    } else {
        gene_annotation <- net$genes_and_modules # color by module color
    }
    kIN <- net$kIN

    # Create a data frame of nodes and node attributes
    geneIDs <- unique(c(as.character(edgelist_gcn[,1]), as.character(edgelist_gcn[,2])))
    nod_at <- data.frame(Gene = geneIDs, stringsAsFactors = FALSE)
    nod_at <- merge(nod_at, gene_annotation, by = 1)
    names(nod_at)[2] <- "Class"
    nod_at$Class <- as.factor(nod_at$Class)
    nod_at$Degree <- kIN$kWithin[rownames(kIN) %in% nod_at$Gene]
    nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)
    nod_at <- nod_at[order(nod_at$Class, -nod_at$Degree), ]

    # Add gene symbols to nod_at
    nod_at <- left_join(nod_at, gene_annots |> select( Gene = gene_id, Symbol = symbol)) 
    
    # Should the network be interactive?
    if(interactive) {

        if(!requireNamespace("networkD3", quietly = TRUE)) {
            stop("`interactive = TRUE` requires the 'networkD3' package.")
        }

        graph <- igraph::simplify(igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed=FALSE))
        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$Class)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        d <- dim_interactive
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                                     Source = 'source', Target = 'target',
                                     NodeID = 'Symbol', Group = 'group',
                                     Nodesize = 'Degree', height=d[2], width=d[1],
                                     opacity=0.8, zoom = TRUE, fontSize = 13)
    } else {
        # Handle gene coloring based on number of annotation classes
        if(nlevels(nod_at$Class) == 1) {
            nodecol <- levels(nod_at$Class)
            add_nodes <- geom_nodes(
                aes(size = .data$Degree, alpha = .data$Degree), color = nodecol
            )
        } else {
            add_nodes <- geom_nodes(
                aes(size = .data$Degree, alpha = .data$Degree, color = .data$Class)
            )
        }

        if(is.data.frame(color_by)) {
            palette <- custom_palette(1)[seq_len(nlevels(nod_at$Class))]
            scale_color <- ggplot2::scale_color_manual(values = palette)
        } else {
            scale_color <- ggplot2::scale_color_manual(values = levels(nod_at$Class))
        }

        # Handle node labeling based on which labels to display (top hubs, hubs or all genes)
        if(show_labels == "all") {
            nod_at$Degree2 <- nod_at$Degree * 0.4
            add_nodelabel <- ggnetwork::geom_nodetext(
                aes(label = .data$Symbol, size = .data$Degree2),
                show.legend = FALSE
            )
        } else if(show_labels == "allhubs") {
            add_nodelabel <- ggnetwork::geom_nodelabel_repel(
                aes(label = .data$Symbol), color = "azure4",
                box.padding = ggnetwork::unit(1, "lines"),
                data = function(x) { x[ x$isHub, ]},
                show.legend = FALSE, max.overlaps = Inf
            )
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][seq_len(top_n_hubs)]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            add_nodelabel <- geom_nodelabel_repel(
                aes(label = .data$Symbol), color = "azure4",
                box.padding = ggnetwork::unit(1, "lines"),
                data = function(x) { x[ x$isTopHub, ]},
                show.legend = FALSE
            )

        } else if(show_labels == "none") {
            add_nodelabel <- NULL
        } else {
            stop("Please, specify a valid option for 'show_labels'.")
        }

        # Create graph object
        graph <- graph_from_data_frame(
            d = edgelist_gcn, vertices = nod_at, directed = FALSE
        )
        n <- ggnetwork(graph, arrow.gap=0, stringsAsFactors = FALSE)

        # Plot graph
        p <- ggplot(
            n, aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend)
        ) +
            geom_edges(
                color = "grey75", alpha = 0.5, curvature = curvature,
                show.legend = FALSE
            ) +
            add_nodes +
            scale_color +
            add_nodelabel +
            ggnetwork::theme_blank()
    }
    return(p)
}

plot_ppi <- function(edgelist_int, color_by = "community",
                     clustering_method = igraph::cluster_infomap,
                     show_labels = "tophubs",
                     top_n_hubs = 5,
                     add_color_legend=TRUE, curvature = 0,
                     interactive = FALSE, dim_interactive = c(600, 600),
                     gene_annots) {

    requireNamespace("intergraph", quietly=TRUE)
    # How should genes be colored?
    if(is.data.frame(color_by)) {
        prot_annotation <- color_by # color by custom annotation
    } else {
        prot_annotation <- detect_communities(edgelist_int,
                                              method = clustering_method,
                                              directed = FALSE)
    }

    # Get degree of nodes and find hubs
    h <- get_hubs_ppi(edgelist_int, return_degree = TRUE)

    # Create a data frame of nodes and node attributes
    protIDs <- unique(c(as.character(edgelist_int[,1]), as.character(edgelist_int[,2])))
    nod_at <- data.frame(Protein = protIDs)
    nod_at$Class <- as.factor(prot_annotation[prot_annotation[,1] %in% nod_at$Protein, 2])
    nod_at$Degree <- h$Degree$Degree[h$Degree$Protein %in% nod_at$Protein]
    nod_at$isHub <- ifelse(nod_at$Protein %in% h$Hubs$Protein, TRUE, FALSE)
    nod_at <- nod_at[order(nod_at$Class, -nod_at$Degree), ]
    
    # Add gene symbols to nod_at
    nod_at <- left_join(nod_at, gene_annots |> select( Protein = gene_id, Symbol = symbol)) 
    
    
    # Should the network be interactive?
    if(interactive) {

        if(!requireNamespace("networkD3", quietly = TRUE)) {
            stop("`interactive = TRUE` requires the 'networkD3' package.")
        }

        graph <- igraph::graph_from_data_frame(d = edgelist_int,
                                               vertices = nod_at, directed=FALSE)
        graph <- igraph::simplify(graph)
        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$Class)
        graph_d3$nodes <- merge(
            graph_d3$nodes, nod_at, by.x = "name", by.y = "Protein", sort = FALSE
        )
        d <- dim_interactive
        p <- networkD3::forceNetwork(
            Links = graph_d3$links, Nodes = graph_d3$nodes,
            Source = 'source', Target = 'target',
            NodeID = 'Symbol', Group = 'group',
            Nodesize = 'Degree', height = d[2], width = d[1],
            opacity=0.8, zoom = TRUE, fontSize = 20
        )

    } else { #Static network
        # Define plotting parameters
        if(nlevels(nod_at$Class) <= 20) {
            palette <- custom_palette(1)
        } else {
            n <- nlevels(nod_at$Class)
            palette <- colorRampPalette(custom_palette(1))(n)
        }

        # Handle legend
        if(add_color_legend) {
            set_legend <- NULL
        } else {
            set_legend <- ggplot2::guides(color = "none")
        }

        # Handle node labeling based on which labels to display (top hubs, hubs or all genes)
        if(show_labels == "all") {
            nod_at$Degree2 <- nod_at$Degree * 0.4
            add_nodelabel <- geom_nodetext(
                aes(label = .data$Symbol, size = .data$Degree2),
                show.legend = FALSE
            )
        } else if(show_labels == "allhubs") {
            add_nodelabel <- geom_nodelabel_repel(
                aes(label = .data$Symbol), color = "azure4",
                box.padding = ggnetwork::unit(1, "lines"),
                data = function(x) { x[ x$isHub, ]},
                show.legend = FALSE, max.overlaps = Inf
            )
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][seq_len(top_n_hubs)]
            nod_at$isTopHub <- ifelse(nod_at$Protein %in% tophubs, TRUE, FALSE)
            add_nodelabel <- geom_nodelabel_repel(
                aes(label = .data$Symbol), color = "azure4",
                box.padding = ggnetwork::unit(1, "lines"),
                data = function(x) { x[ x$isTopHub, ]},
                show.legend = FALSE, max.overlaps = Inf
            )

        } else if(show_labels == "none") {
            add_nodelabel <- NULL
        } else {
            stop("Please, specify a valid option for 'show_labels'.")
        }

        # Create graph object
        graph <- simplify(graph_from_data_frame(
            d = edgelist_int, vertices = nod_at, directed = FALSE
        ))
        n <- ggnetwork::ggnetwork(graph, arrow.gap = 0, stringsAsFactors=F)

        # Plot graph
        p <- ggplot(
            n, aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend)
        ) +
            geom_edges(
                color = "grey75", alpha = 0.5, curvature = curvature,
                show.legend = FALSE
            ) +
            geom_nodes(aes(size = .data$Degree, color = .data$Class)) +
            set_legend +
            scale_color_manual(values = palette) +
            add_nodelabel +
            ggnetwork::theme_blank()
    }

    return(p)
}

custom_palette <- function(pal = 1) {
    pal1 <- c("#1F77B4FF", "#FF7F0EFF", "#2CA02CFF", "#D62728FF",
              "#9467BDFF", "#8C564BFF", "#E377C2FF", "#7F7F7FFF",
              "#BCBD22FF", "#17BECFFF", "#AEC7E8FF", "#FFBB78FF",
              "#98DF8AFF", "#FF9896FF", "#C5B0D5FF", "#C49C94FF",
              "#F7B6D2FF", "#C7C7C7FF", "#DBDB8DFF", "#9EDAE5FF")

    pal2 <- c("#3182BDFF", "#E6550DFF", "#31A354FF", "#756BB1FF",
              "#636363FF", "#6BAED6FF", "#FD8D3CFF", "#74C476FF",
              "#9E9AC8FF", "#969696FF", "#9ECAE1FF", "#FDAE6BFF",
              "#A1D99BFF", "#BCBDDCFF", "#BDBDBDFF", "#C6DBEFFF",
              "#FDD0A2FF", "#C7E9C0FF", "#DADAEBFF", "#D9D9D9FF")

    pal3 <- c("#393B79FF", "#637939FF", "#8C6D31FF", "#843C39FF",
              "#7B4173FF", "#5254A3FF", "#8CA252FF", "#BD9E39FF",
              "#AD494AFF", "#A55194FF", "#6B6ECFFF", "#B5CF6BFF",
              "#E7BA52FF", "#D6616BFF", "#CE6DBDFF", "#9C9EDEFF",
              "#CEDB9CFF", "#E7CB94FF", "#E7969CFF", "#DE9ED6FF")

    l <- list(pal1, pal2, pal3)
    l_final <- l[[pal]]
    return(l_final)
}

plot_grn <- function(edgelist_grn, show_labels = "tophubs", top_n_hubs = 5,
                     layout = igraph::with_kk, arrow.gap = 0.01,
                     ranked = TRUE, curvature = 0.1,
                     interactive = FALSE, dim_interactive = c(600,600),
                     gene_annots) {

    requireNamespace("intergraph", quietly = TRUE)

    # Get degree of nodes and find hubs
    h <- get_hubs_grn(edgelist_grn, return_degree = TRUE, ranked = ranked)

    # Create a data frame of nodes and node attributes
    geneIDs <- unique(c(as.character(edgelist_grn[,1]), as.character(edgelist_grn[,2])))
    nod_at <- data.frame(Gene = geneIDs, stringsAsFactors = FALSE)
    nod_at$Class <- ifelse(nod_at$Gene %in% edgelist_grn[,1], "Regulator", "Target")
    nod_at$Degree <- h$Degree$Degree[h$Degree$Gene %in% nod_at$Gene]
    nod_at$isHub <- ifelse(nod_at$Gene %in% h$Hubs$Gene, TRUE, FALSE)
    nod_at <- nod_at[order(nod_at$Class, -nod_at$Degree), ]

    # Add gene symbols to nod_at
    nod_at <- left_join(nod_at, gene_annots |> select( Gene = gene_id, Symbol = symbol)) 
    
    # Should the network be interactive?
    if(interactive) {

        if(!requireNamespace("networkD3", quietly = TRUE)) {
            stop("`interactive = TRUE` requires the 'networkD3' package.")
        }

        graph <- igraph::graph_from_data_frame(d = edgelist_grn,
                                               vertices = nod_at, directed=TRUE)
        graph <- igraph::simplify(graph)
        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$Class)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        my_color <- 'd3.scaleOrdinal() .domain(["Regulator", "Target"]) .range(["forestgreen", "orange"])'
        d <- dim_interactive
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                                     Source = 'source', Target = 'target',
                                     NodeID = 'Symbol', Group = 'group',
                                     colourScale = my_color,
                                     Nodesize = 'Degree', height=d[2], width=d[1],
                                     opacity=1, zoom = TRUE, fontSize = 20, legend=TRUE)

    } else { #Static network
        # Define plotting parameters
        add_edges <- geom_edges(
            color = "grey60", alpha = 0.3, arrow = ggplot2::arrow(
                length = ggnetwork::unit(0.1, "lines"), type = "closed"
            ), curvature = curvature, show.legend = FALSE
        )

        # Handle node labeling based on which labels to display (top hubs, hubs or all genes)
        if(show_labels == "all") {
            nod_at$Degree2 <- nod_at$Degree * 0.4
            add_nodelabel <- geom_nodetext(
                aes(label = .data$Symbol, size = .data$Degree2),
            show.legend = FALSE)

        } else if(show_labels == "allhubs") {
            add_nodelabel <- geom_nodelabel_repel(
                aes(label = .data$Symbol), color = "azure4",
                box.padding = ggnetwork::unit(1, "lines"),
                data = function(x) { x[ x$isHub, ]},
                show.legend = FALSE, max.overlaps = Inf
            )
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][seq_len(top_n_hubs)]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            add_nodelabel <- geom_nodelabel_repel(
                aes(label = .data$Symbol), color = "azure4",
                box.padding = ggnetwork::unit(1, "lines"),
                data = function(x) { x[ x$isTopHub, ]},
                show.legend = FALSE, max.overlaps = Inf
            )
        } else if(show_labels == "none") {
            add_nodelabel <- NULL
        } else {
            stop("Please, specify a valid option for 'show_labels'.")
        }
        # Create graph object
        graph <- graph_from_data_frame(
            d = edgelist_grn, vertices = nod_at, directed = TRUE
        )
        graph <- igraph::simplify(graph)
        n <- ggnetwork(graph, layout = layout(), arrow.gap = arrow.gap, stringsAsFactors=F)
        n$Class <- factor(n$Class, levels=c("Target", "Regulator"))

        # Plot graph
        p <- ggplot(
            n, aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend)
        ) +
            add_edges +
            geom_nodes(
                aes(fill = .data$Class),
                shape = 21, color = "gray40"
            ) +
            scale_fill_manual(values = c("darkolivegreen3", "mediumpurple3")) +
            add_nodelabel +
            ggnetwork::theme_blank()
        }
    return(p)
}


```

::: {#WGCNA_subnetworks .panel-tabset .nav-pills}
```{r}
#| label: b6_gcn_plots
#| warning: false
#| message: false
#| results: asis
#| fig-width: 12
#| fig-height: 10

modules <- unique(net_b6$genes_and_modules$Modules)
for( mod in modules){
  p_gcn <- plot_gcn(
      edgelist_gcn = edges_filt_b6[[mod]],
      net = net_b6,
      hubs = hubs_b6,
      gene_annots = all_genes_palate,
      show_labels = "tophubs", top_n_hubs = 20,
      interactive = F
  )
  p_ppi <- plot_ppi(
    edgelist_int = edges_filt_b6[[mod]], 
    show_labels = "tophubs", 
    top_n_hubs = 20,
    gene_annots = all_genes_palate, 
    add_color_legend = F
  )
  cat("\n#####",mod, "module","\n")
  print(p_gcn)
  print(p_ppi)
  cat("\n \n")
  
}


```
:::
:::::

## CAST

```{r}
#| warning: false
#| message: false
#| label: choose_sft_power_cast
#| results: hide

# Choose a set of soft-thresholding powers
cast_sft <- SFT_fit(cast_expr_final, 
                    net_type = "signed",  
                  cor_method = "pearson",
                  rsquared = 0.7 
                  )
```

```{r}
#| label: sft_power_plot_cast
#| fig-width: 12
#| fig-height: 5
cast_sft$plot 
```

```{r}
#| label: run_wgcna_cast
#| warning: false
#| message: false
#| results: hide

power_cast <- cast_sft$power

net_cast <- exp2gcn(
    cast_expr_final, 
    net_type = "signed", 
  #  module_merging_threshold = 0.75,
    SFTpower = power_cast, 
    cor_method = "pearson"
)

# plot_dendro_and_colors(net_cast)
# plot_eigengene_network(net_cast)
# plot_ngenes_per_module(net_cast)


```

Assessing module stability by re-sampling:

```{r}
#| label: module_stability_cast
#| warning: false
#| message: false
#| cache: true
#| results: hide
 
#net_cast$params$cor_method <- "bicor"
module_stability(cast_expr_final, net_cast, nRuns = 50)


```

Using `r formatC(nrow(cast_expr_final),big.mark=",")` genes and `r formatC(ncol(cast_expr_final),big.mark=",")` samples.

-   `net_type = "signed"` : I chose this option to get more biologically meaningful networks where the sign of the correlation is preserved and module detection focuses on positively correlated genes.

-   `cor_method = "pearson"`: I chose Pearson correlation because our data is relatively clean.

-   `SFTpower =` `r power_cast`: as the threshold for power since it is where the 0.7 R\^2 threshold is reached first.

This leads to `r ncol(net_cast$MEs)` modules in total which are characterized below.
Remember the 'grey' module is a catch all module where WGCNA places the genes that cannot be assigned to any specific module.

::::: {.panel-tabset .nav-pills}
### Eigengene adjacency plot

```{r}
#| label: eigengene_network_plot_cast
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 8

# I got the code from the bionero plot_eigengene_network function's source code
mes_cast <- net_cast$MEs[, !names(net_cast$MEs) %in% "MEgrey"]
me_correlation_cast <- cor(mes_cast)

clusters <- hclust(as.dist(1 - me_correlation_cast), method = "average")
# Create column metadata and row metadata
coldata <- data.frame(row.names = names(mes_cast), Module = names(mes_cast))
rowdata <- data.frame(row.names = names(mes_cast), Module = names(mes_cast))

colors <- list(
        Module = setNames(gsub("ME", "", names(mes_cast)), names(mes_cast))
    )

# Plot heatmap with distances
pal <- colorRampPalette(RColorBrewer::brewer.pal(n = 7, name = "PRGn"))(100)
pheatmap(
        me_correlation_cast, name = "Correlation",
        color = pal,
        cluster_cols = clusters,
        cluster_rows = clusters,
        # clustering_distance_rows = "correlation",
        # clustering_distance_cols = "correlation",
        # clustering_method = "average",
        main = "Pairwise correlations between module eigengenes",
        legend_breaks = seq(-1, 1, 0.5),
        breaks = seq(-1, 1, 0.02),
        annotation_row = rowdata,
        annotation_col = coldata,
        legend = TRUE,
        annotation_colors = colors,
        annotation_legend = FALSE
          
    )
    

```

### Module genes

```{r}
#| label: module_genes_table_cast
#| message: false
#| warning: false


net_cast$genes_and_modules |> 
  left_join( all_genes_palate |> 
               select( Genes = gene_id, symbol, chromosome)
            ) |> 
  group_by(Modules) |> 
  arrange(Modules, symbol) |> 
  create_dt()

```

### Module eigengenes

```{r}
#| label: module_eigengenes_all_cast
#| warning: false
#| message: false
#| results: asis
#| fig-width: 16
#| fig-height: 14

module_eigenges_cast <- net_cast$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(cast_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long_cast <-  module_eigenges_cast |> 
  pivot_longer( 2:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long_cast |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = AP_domain)+
    geom_jitter()+
    geom_smooth( aes(col = AP_domain))+
    scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 3)


```

::: {.panel-tabset .nav-pills}
```{r}
#| label: module_eigengene_plots_cast
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

plot_eigengene_by_module_genes <- function(mod_name, module_eigengenes_long, expr, coldata,module_genes){
    
    df <- module_eigengenes_long |> 
      filter( module == mod_name) |> 
      arrange( value) |> 
      mutate( sample = as_factor(sample))
  
    eigengene_plot <- df |> 
      ggplot()+
      aes( y = value, x= LB_stage, col = AP_domain)+
      geom_jitter()+
      geom_smooth( aes(col = AP_domain))+
      scale_color_manual( values = domain_colors)+
      theme_pubclean(base_size = 16)+
      theme( legend.position = "top")+
      xlab("LB stage")+
      ylab("Module summary eigengene")
    
    mod_genes <- module_genes |> 
      filter(Modules ==gsub("ME","",mod_name))
    
    coldata_ordered <- coldata |> 
      as_tibble(rownames = "sample") |> 
      arrange(LB_stage,AP_domain) |> 
      column_to_rownames("sample") |> 
      as.matrix()
    
    mat <- log1p(assay(expr)[mod_genes$Genes, rownames(coldata_ordered), drop = FALSE])
    
    gene_plot <- pheatmap(mat = mat,
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = coldata[,c("AP_domain","LB_stage","Palate_ori","sex")],
         annotation_colors = list( 
                    #strain = strain_colors[c("cast","CAST")],
                    AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
                    ),
         treeheight_row = 0, 
         treeheight_col = 0,
         silent = TRUE
    )
    
    ggarrange( ggarrange(eigengene_plot,NULL, nrow = 1, widths = c(1, 0.2)), 
               ggarrange( NULL, gene_plot$gtable, widths = c(0.1, 1)),
               ncol = 1, nrow = 2, heights = c(.8,1))
}

module_genes_cast <- net_cast$genes_and_modules
module_colors_cast <- unique(module_eigengenes_long_cast$mod_col)
names(module_colors_cast) <- paste0("ME",module_colors_cast)


for(mod in names(module_colors_cast)){
  
  cat("\n#####",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_module_genes(mod, module_eigengenes_long_cast, cast_expr_final, cast_coldata, module_genes_cast))
  cat("\n \n")
  
}


```
:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_cast
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
cast_me_trait_cor <- c()
for(i in 1:(ncol(cast_datTraits_alt)-1)){
  
  cast_me_trait_cor[[colnames(cast_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(cast_expr_final), # get just the expression
                                            metadata = cast_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_cast$MEs,
                                            #continuous_trait = is.numeric(cast_datTraits_alt[1,i]),
                                            #palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp_cast <- reshape2::melt(cast_me_trait_cor) |> 
  select(-L1) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat_cast <- reshape2::dcast(corandp_cast, ME ~ trait, value.var = "cor")
rownames(cormat_cast) <- cormat_cast$ME
cormat_cast$ME <- NULL
cormat_cast <- as.matrix(cormat_cast)
cormat_cast[is.na(cormat_cast)] <- 0

pmat_cast <- reshape2::dcast(corandp_cast, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat_cast) <- pmat_cast$ME
pmat_cast$ME <- NULL
pmat_cast[is.na(pmat_cast)] <- ""

```

```{r}
#| label: module_trait_cor_plot_cast
#| fig-width: 10
#| fig-height: 6
corrplot(corr = cormat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F],
         p.mat = as.matrix(pmat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(10,12), ylim=c(2,12), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r}
#| label: module_trait_cor_table_cast
#| warning: false
#| message: false
cormat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:9, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:9, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

```{r }
#| label: wgcna_module_ora_cast
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
ora_results <- c()
modules <- unique(net_cast$genes_and_modules$Modules)
for( mod in modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_cast$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = wgcna_genes$symbol,
                        evcodes = TRUE)
  ora_results[[mod]] <- g.mod
}

```

```{r }
#| label: wgcna_ora_restuls_table_cast
#| eval: true
do.call( rbind, ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```

### Hub genes

Hub genes are often identified using two different metrics: module membership (MM) (i.e., correlation of a gene to its module eigengene) and degree (i.e., sum of connection weights of a gene to all other genes in the module).
Some researchers consider the top 10% genes with the highest degree as hubs, while others consider those with MM \> 0.8.
To avoid false positives, BioNEROs algorithm combines both metrics and defines hub genes as the top 10% genes with highest degree that have MM \> 0.8.
Hubs are identigied with the function `get_hubs_gcn()` below.

```{r}
#| label: get_hub_genes_cast
#net_b6$params$cor_method <- "biweight"
hubs_cast <- get_hubs_gcn(cast_expr_final, net_cast)

hubs_cast |> 
  left_join( all_genes_palate |> 
               select( Gene = gene_id, symbol)) |> 
  select( Gene, Symbol = symbol, Module, kWithin) |> 
  mutate( kWithin = round(kWithin , 2)) |> 
  create_dt()

```

Below I am getting the sub-networks within each module then plotting them per module.
I am also plotting the protein-protein interaction networks within each module with communities detected in each one.
Note that some modules are really big, hence the networks are really big as well!
I am only labeling the 15 top hub genes in each network.

```{r}
#| label: get_subnetworks_cast
#| results: hold
#| warning: false
#| message: false
#| fig-show: hide


modules <- unique(net_cast$genes_and_modules$Modules)
edges_filt_cast <- list()
for(mod in modules){
  # Remove edges based on optimal scale-free topology fit
  edges_filtered <- get_edge_list(net_cast, module = mod, filter = TRUE)  
  edges_filt_cast[[mod]] <- edges_filtered
}

```

::: {#WGCNA_subnetworks_cast .panel-tabset .nav-pills}
```{r}
#| label: cast_gcn_plots
#| warning: false
#| message: false
#| results: asis
#| fig-width: 12
#| fig-height: 10

modules <- unique(net_cast$genes_and_modules$Modules)
for( mod in modules){
  p_gcn <- plot_gcn(
      edgelist_gcn = edges_filt_cast[[mod]],
      net = net_cast,
      hubs = hubs_cast,
      gene_annots = all_genes_palate,
      show_labels = "tophubs", top_n_hubs = 20,
      interactive = F
  )
  p_ppi <- plot_ppi(
    edgelist_int = edges_filt_cast[[mod]], 
    show_labels = "tophubs", 
    top_n_hubs = 20,
    gene_annots = all_genes_palate, 
    add_color_legend = F
  )
  cat("\n#####",mod, "module","\n")
  print(p_gcn)
  print(p_ppi)
  cat("\n \n")
  
}


```
:::
:::::

## Comparison of B6 and CAST modules

Module preservation: The B6 modules named below are preserved in the CAST data.

```{r}
#| label: b6_cast_mod_preservation
#| warning: false
#| message: false
#| results: hide


b6_and_cast <- c(b6=b6_expr_final, 
                 cast = cast_expr_final)
# net_b6$params$cor_method <- "biweight"
# net_cast$params$cor_method <- "biweight"
pres_b6_cast <- module_preservation( b6_and_cast,
                            ref_net = net_b6, 
                            test_net = net_cast, 
                            algorithm = "netrep",
                            nThreads = 40)

# This is how it gets the preserved modules in the original function
max_pval_b6_cast <- apply(pres_b6_cast$p.value, 1, max, na.rm = TRUE)
preserved_modules_b6_cast <- names(max_pval_b6_cast[max_pval_b6_cast < 0.05])
```

```{r}
pres_b6_cast$p.values |> 
  as_tibble( rownames = "Module") |> 
  filter( Module %in% preserved_modules_b6_cast) |> 
  mutate_if( is.numeric, formatC, digits =2 ) |> 
  create_dt()



```

```{r}
#| label: compare_module_functions

calculate_overlap <- function(module1, module2, genes1, genes2) {
  intersection <- length(intersect(module1, module2))
  union <- length(unique(c(module1, module2)))
  jaccard <- if (union > 0) intersection / union else 0
  
  # Fisher's exact test
  m1_size <- length(module1)
  m2_size <- length(module2)
  total_genes <- length(union(genes1, genes2))
  
  # Create the contingency table
  contingency <- matrix(c(intersection, 
                          m1_size - intersection,
                          m2_size - intersection, 
                          total_genes - m1_size - m2_size + intersection),
                        nrow = 2)
  
  # Only perform Fisher's test if there's an overlap
  if (intersection > 0) {
    fisher_p <- fisher.test(contingency)$p.value
  } else {
    fisher_p <- 1  # No overlap means no significance
  }
  
  return(c(jaccard = jaccard, p_value = fisher_p, overlap = intersection))
}

compare_networks <- function(network1, network2) {
  modules1 <- split(network1$gene, network1$module)
  modules2 <- split(network2$gene, network2$module)
  genes1 <- unique(network1$gene)
  genes2 <- unique(network2$gene)
  
  results <- expand.grid(module1 = names(modules1), module2 = names(modules2))
  results$jaccard <- 0
  results$p_value <- 1
  results$overlap_count <- 0
  
  for (i in 1:nrow(results)) {
    m1 <- modules1[[results$module1[i]]]
    m2 <- modules2[[results$module2[i]]]
    overlap <- calculate_overlap(m1, m2, genes1, genes2)
    results$jaccard[i] <- overlap["jaccard"]
    results$p_value[i] <- overlap["p_value"]
    results$overlap_count[i] <- overlap["overlap"]
  }
  
  # Add module sizes
  results$size1 <- lengths(modules1)[results$module1]
  results$size2 <- lengths(modules2)[results$module2]
  
  return(results)
}

plot_module_overlap <- function(comparison_results, p_threshold = 0.05, highlight_modules = NULL) {
  # Prepare data for plotting
  plot_data <- comparison_results %>%
    arrange(desc(overlap_count)) %>%
    mutate(
      text_color = ifelse(adj_p_value < p_threshold, "cyan", "black"),
      module1 = factor(module1, levels = unique(module1)),
      module2 = factor(module2, levels = unique(module2)),
      highlight_color = ifelse(!is.null(highlight_modules) & module1 %in% highlight_modules, "red", "black")
    )

  # Create a named vector of colors for x-axis labels
  x_label_colors <- ifelse(levels(plot_data$module1) %in% highlight_modules, "red", "black")
  names(x_label_colors) <- levels(plot_data$module1)
  
  # Create the heatmap
  ggplot(plot_data, aes(x = module1, y = module2, fill = jaccard)) +
    geom_tile(color = "white") +
    scale_fill_viridis_b(
      option = "plasma",  # This gives a nice blue to yellow gradient
      name = "Jaccard Index"
    ) +
    geom_text(
      aes(label = overlap_count, color = text_color),
      size = 3
    ) +
    scale_color_identity() +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, color = x_label_colors),
      axis.title = element_text(face = "bold"),
      legend.position = "right",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    labs(
      x = "Network 1 Modules", 
      y = "Network 2 Modules", 
      title = "Module Overlap between Networks",
      subtitle = paste("Cyan text indicates significant overlap (adj. p <", p_threshold, ")")
    ) +
    coord_fixed() + # This ensures that the tiles are square
    scale_x_discrete(labels = function(x) {
      ifelse(x %in% highlight_modules, paste0(x, "*"), x)
    })
}

```

Let's compare modules by calculating the \# of genes that overlap between modules and the Jaccard Index.
The Jaccard Index is a way to measure how similar two sets are by comparing the number of items they have in common to the total number of unique items in both sets.
The modules colored red with an asterisk are also identified as B6 modules preserved in CAST network.
We can use the Jaccard index and the significant overlap according to Fisher's test to identify which CAST modules likely correspond to the conserved B6 modules For example, the B6 green module has a significant overlap and high Jaccard index with the CAST dark turquoise module suggesting that it is the equivalent module in the CAST data.

```{r}
#| label: compare_b6_to_cast
#| warning: false
#| message: false
#| fig-height: 6
#| fig-width: 12

network1 <- net_b6$genes_and_modules |> 
  rename(gene = Genes, module = Modules)
network2 <- net_cast$genes_and_modules |> 
  rename(gene = Genes, module = Modules)

comparison_results <- compare_networks(network1, network2)
comparison_results$adj_p_value <- p.adjust(comparison_results$p_value, method = "BH")

# Create the plot
plot_module_overlap(comparison_results, p_threshold = 0.01, highlight_modules = preserved_modules_b6_cast)+
    labs(
      x = "B6", 
      y = "CAST"
      )

```

```{r}
#| eval: false
consensus <- consensus_modules(b6_and_cast, power = c(20,20), cor_method = "pearson", net_type = "signed")

names(consensus)


plot_dendro_and_cons_colors(consensus)

consensus_trait <- consensus_trait_cor(consensus, cor_method = "pearson")
head(consensus_trait)

```

## DO - only MAX domain

```{r}
#| warning: false
#| message: false
#| label: choose_sft_power_do
#| results: hide

# Choose a set of soft-thresholding powers
do_sft <- SFT_fit(do_expr_final, net_type = "signed", cor_method = "pearson")
```

```{r}
#| label: sft_power_plot_do
#| fig-width: 12
#| fig-height: 5
do_sft$plot 
```

```{r}
#| label: run_wgcna_do
#| warning: false
#| message: false
#| results: hide

power_do <- do_sft$power

net_do <- exp2gcn(
    do_expr_final, 
    net_type = "signed", 
    #module_merging_threshold = 0.75,
    SFTpower = power_do, 
    cor_method = "pearson"
)

# plot_dendro_and_colors(net_do)
# plot_eigengene_network(net_do)
# plot_ngenes_per_module(net_do)

# saving the network to use in the qtl mapping notebook
# save(net_do,  file = here("_data",paste0("/DO_WGCNA_network_",Sys.Date(), ".RData")) ) 
```

Assessing module stability by re-sampling:

```{r}
#| label: module_stability_do
#| warning: false
#| message: false
#| cache: true
#| results: hide
 

module_stability(do_expr_final, net_do, nRuns = 30)


```

Using `r formatC(nrow(do_expr_final),big.mark=",")` genes and `r formatC(ncol(do_expr_final),big.mark=",")` samples.

-   `net_type = "signed"` : I chose this option so that we can treat positive and negative correlations equally and focus on the strength of the relationship rather than the sign.

-   `cor_method = "pearson"`: I chose Pearson correlation because our data is relatively clean.

-   ``` SFTpower =``r do_sft$power ```: as the thresholding power.

This leads to `r ncol(net_do$MEs)` modules in total which are characterized below.
Remember the 'grey' module is a catch all module where WGCNA places the genes that cannot be assigned to any specific module.

::::: {.panel-tabset .nav-pills}
### Eigengene adjacency plot

```{r}
#| label: eigengene_network_plot_do
#| warning: false
#| message: false
#| fig-width: 6
#| fig-height: 6
#| 
# I got the code from the bionero plot_eigengene_network function's source code
mes_do <- net_do$MEs[, !names(net_do$MEs) %in% "MEgrey"]
me_correlation_do <- cor(mes_do)

clusters <- hclust(as.dist(1 - me_correlation_do), method = "average")
# Create column metadata and row metadata
coldata <- data.frame(row.names = names(mes_do), Module = names(mes_do))
rowdata <- data.frame(row.names = names(mes_do), Module = names(mes_do))

colors <- list(
        Module = setNames(gsub("ME", "", names(mes_do)), names(mes_do))
    )

# Plot heatmap with distances
pal <- colorRampPalette(RColorBrewer::brewer.pal(n = 7, name = "PRGn"))(100)
pheatmap(
        me_correlation_do, name = "Correlation",
        color = pal,
        cluster_cols = clusters,
        cluster_rows = clusters,
        # clustering_distance_rows = "correlation",
        # clustering_distance_cols = "correlation",
        # clustering_method = "average",
        main = "Pairwise correlations between module eigengenes",
        legend_breaks = seq(-1, 1, 0.5),
        breaks = seq(-1, 1, 0.02),
        annotation_row = rowdata,
        annotation_col = coldata,
        legend = TRUE,
        annotation_colors = colors,
        annotation_legend = FALSE
          
    )
    

```

### Module genes

```{r}
#| label: module_genes_table_do
#| message: false
#| warning: false


net_do$genes_and_modules |> 
  left_join( all_genes_palate |> 
               select( Genes = gene_id, symbol, chromosome)
            ) |> 
  group_by(Modules) |> 
  arrange(Modules, symbol) |> 
  create_dt()

```

### Module eigengenes

```{r}
#| label: module_eigengenes_all_do
#| warning: false
#| message: false
#| results: asis
#| fig-width: 12
#| fig-height: 10

module_eigenges_do <- net_do$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(do_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long_do <-  module_eigenges_do |> 
  pivot_longer( 2:MEgreen, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long_do |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = sex)+
    geom_jitter()+
    geom_smooth( aes(col = sex))+
    #scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 2)


```

::: {.panel-tabset .nav-pills}
```{r}
#| label: module_eigengene_plots_do
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

plot_eigengene_by_module_genes <- function(mod_name, module_eigengenes_long, expr, coldata,module_genes){
    
    df <- module_eigengenes_long |> 
      filter( module == mod_name) |> 
      arrange( value) |> 
      mutate( sample = as_factor(sample))
  
    eigengene_plot <- df |> 
      ggplot()+
      aes( y = value, x= LB_stage, col = sex)+
      geom_jitter()+
      geom_smooth( aes(col = sex))+
      #scale_color_manual( values = domain_colors)+
      theme_pubclean(base_size = 16)+
      theme( legend.position = "top")+
      xlab("LB stage")+
      ylab("Module summary eigengene")
    
    mod_genes <- module_genes |> 
      filter(Modules ==gsub("ME","",mod_name))
    
    coldata_ordered <- coldata |> 
      as_tibble(rownames = "sample") |> 
      arrange(LB_stage,sex) |> 
      column_to_rownames("sample") |> 
      as.matrix()
    
    mat <- log1p(assay(expr)[mod_genes$Genes, rownames(coldata_ordered), drop = FALSE])
    
    gene_plot <- pheatmap(mat = mat,
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = coldata[,c("sex","LB_stage","Palate_ori")],
         annotation_colors = list( 
                    #strain = strain_colors[c("do","do")],
                    #AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
                    ),
         treeheight_row = 0, 
         treeheight_col = 0,
         silent = TRUE
    )
    
    ggarrange( ggarrange(eigengene_plot,NULL, nrow = 1, widths = c(1, 0.2)), 
               ggarrange( NULL, gene_plot$gtable, widths = c(0.1, 1)),
               ncol = 1, nrow = 2, heights = c(.8,1))
}

module_genes_do <- net_do$genes_and_modules
module_colors_do <- unique(module_eigengenes_long_do$mod_col)
names(module_colors_do) <- paste0("ME",module_colors_do)


for(mod in names(module_colors_do)){
  
  cat("\n#####",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_module_genes(mod, module_eigengenes_long_do, do_expr_final, do_coldata, module_genes_do))
  cat("\n \n")
  
}


```
:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_do
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
do_me_trait_cor <- c()
do_datTraits_alt <- do_datTraits_alt |> 
  select(-strain, -AP_domain, -Gest_stage)
for(i in 1:(ncol(do_datTraits_alt))){
  
  do_me_trait_cor[[colnames(do_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(do_expr_final), # get just the expression
                                            metadata = do_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_do$MEs,
                                            #continuous_trait = is.numeric(do_datTraits_alt[1,i]),
                                            #palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp_do <- reshape2::melt(do_me_trait_cor) |> 
  select(-L1) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat_do <- reshape2::dcast(corandp_do, ME ~ trait, value.var = "cor")
rownames(cormat_do) <- cormat_do$ME
cormat_do$ME <- NULL
cormat_do <- as.matrix(cormat_do)
cormat_do[is.na(cormat_do)] <- 0

pmat_do <- reshape2::dcast(corandp_do, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat_do) <- pmat_do$ME
pmat_do$ME <- NULL
pmat_do[is.na(pmat_do)] <- ""

```

```{r}
#| label: module_trait_cor_plot_do
#| fig-width: 8
#| fig-height: 6
corrplot(corr = cormat_do[,c("M","F","LB_stage","Left","Right"),drop=F],
         p.mat = as.matrix(pmat_do[,c("M","F","LB_stage","Left","Right"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(5.7,6.7), ylim=c(1,5), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r}
#| label: module_trait_cor_table_do
#| warning: false
#| message: false
cormat_do[,c("M","F","LB_stage","Left","Right"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:6, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat_do[,c("M","F","LB_stage","Left","Right"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:6, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

```{r }
#| label: wgcna_module_ora_do
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
ora_results <- c()
modules <- unique(net_do$genes_and_modules$Modules)
for( mod in modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_do$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = wgcna_genes$symbol,
                        evcodes = TRUE)
  ora_results[[mod]] <- g.mod
}

```

```{r }
#| label: wgcna_ora_restuls_table_do
#| eval: true
do.call( rbind, ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```

### Hub genes

Hub genes are often identified using two different metrics: module membership (MM) (i.e., correlation of a gene to its module eigengene) and degree (i.e., sum of connection weights of a gene to all other genes in the module).
Some researchers consider the top 10% genes with the highest degree as hubs, while others consider those with MM \> 0.8.
To avoid false positives, BioNEROs algorithm combines both metrics and defines hub genes as the top 10% genes with highest degree that have MM \> 0.8.
Hubs are identigied with the function `get_hubs_gcn()` below.

```{r}
#| label: get_hub_genes_do

hubs_do <- get_hubs_gcn(do_expr_final, net_do)

hubs_do |> 
  left_join( all_genes_palate |> 
               select( Gene = gene_id, symbol)) |> 
  select( Gene, Symbol = symbol, Module, kWithin) |> 
  mutate( kWithin = round(kWithin , 2)) |> 
  create_dt()

```

Below I am getting the sub-networks within each module then plotting them per module.
I am also plotting the protein-protein interaction networks within each module with communities detected in each one.
Note that some modules are really big, hence the networks are really big as well!
I am only labeling the 15 top hub genes in each network.

```{r}
#| label: get_subnetworks_do
#| results: hold
#| warning: false
#| message: false
#| fig-show: hide


modules <- unique(net_do$genes_and_modules$Modules)
edges_filt_do <- list()
for(mod in modules){
  # Remove edges based on optimal scale-free topology fit
  edges_filtered <- get_edge_list(net_do, module = mod, filter = TRUE)  
  edges_filt_do[[mod]] <- edges_filtered
}

```

::: {.panel-tabset .nav-pills}
```{r}
#| label: do_gcn_plots
#| warning: false
#| message: false
#| results: asis
#| fig-width: 12
#| fig-height: 10

modules <- unique(net_do$genes_and_modules$Modules)
for( mod in modules){
  p_gcn <- plot_gcn(
      edgelist_gcn = edges_filt_do[[mod]],
      net = net_do,
      hubs = hubs_do,
      gene_annots = all_genes_palate,
      show_labels = "tophubs", top_n_hubs = 20,
      interactive = F
  )
  p_ppi <- plot_ppi(
    edgelist_int = edges_filt_do[[mod]], 
    show_labels = "tophubs", 
    top_n_hubs = 20,
    gene_annots = all_genes_palate, 
    add_color_legend = F
  )
  cat("\n#####",mod, "module","\n")
  print(p_gcn)
  print(p_ppi)
  cat("\n \n")
  
}


```
:::
:::::

## Comparison of DO modules with B6 and CAST

Module preservation: The B6 modules named below are preserved in the DO data.

```{r}
#| label: do_b6_mod_preservation
#| warning: false
#| message: false
#| results: hide



b6_and_do <- c(b6=b6_expr_final, 
                 do = do_expr_final)

pres_b6_do <- module_preservation( b6_and_do,
                            ref_net = net_b6, 
                            test_net = net_do, 
                            algorithm = "netrep",
                            nThreads = 40)

# This is how it gets the preserved modules in the original function
max_pval_b6_do <- apply(pres_b6_do$p.value, 1, max, na.rm = TRUE)
preserved_modules_b6_do <- names(max_pval_b6_do[max_pval_b6_do < 0.05])
```

```{r}
pres_b6_do$p.values |> 
  as_tibble( rownames = "Module") |> 
  filter( Module %in% preserved_modules_b6_do) |> 
  mutate_if( is.numeric, formatC, digits =2 ) |> 
  create_dt()



```

Let's compare modules by calculating the \# of genes that overlap between modules and the Jaccard Index.
The Jaccard Index is a way to measure how similar two sets are by comparing the number of items they have in common to the total number of unique items in both sets.
The modules colored red with an asterisk are also identified as B6 modules preserved in the DO network.
We can use the Jaccard index and the significant overlap according to Fisher's test to identify which DO modules likely correspond to the conserved B6 modules.

```{r}
#| label: compare_b6_to_do
#| fig-height: 6
#| fig-width: 12
#| warning: false
#| message: false
network1 <- net_b6$genes_and_modules |> 
  rename(gene = Genes, module = Modules)
network2 <- net_do$genes_and_modules |> 
  rename(gene = Genes, module = Modules)

comparison_results <- compare_networks(network1, network2)
comparison_results$adj_p_value <- p.adjust(comparison_results$p_value, method = "BH")

# Create the plot
plot_module_overlap(comparison_results, p_threshold = 0.01, highlight_modules = preserved_modules_b6_do)+
    labs(
      x = "B6", 
      y = "DO"
      )

```

Module preservation: The CAST modules named below are preserved in the DO data.

```{r}
#| label: do_cast_mod_preservation
#| warning: false
#| message: false
#| results: hide


cast_and_do <- c(cast = cast_expr_final, 
                 do = do_expr_final)

pres_cast_do <- module_preservation( cast_and_do,
                            ref_net = net_cast, 
                            test_net = net_do, 
                            algorithm = "netrep",
                            nThreads = 40)

# This is how it gets the preserved modules in the original function
max_pval_cast_do <- apply(pres_cast_do$p.value, 1, max, na.rm = TRUE)
preserved_modules_cast_do <- names(max_pval_cast_do[max_pval_cast_do < 0.05])
 

pres_cast_do$p.values |> 
  as_tibble( rownames = "Module") |> 
  filter( Module %in% preserved_modules_cast_do) |> 
  mutate_if( is.numeric, formatC, digits =2 ) |> 
  create_dt()



```

Let's compare modules by calculating the \# of genes that overlap between modules and the Jaccard Index.
The Jaccard Index is a way to measure how similar two sets are by comparing the number of items they have in common to the total number of unique items in both sets.
The modules colored red with an asterisk are also identified as CAST modules preserved in the DO network.
We can use the Jaccard index and the significant overlap according to Fisher's test to identify which DO modules likely correspond to the conserved CAST modules.

```{r}
#| label: compare_cast_to_do
#| fig-height: 6
#| fig-width: 12
#| warning: false
#| message: false
network1 <- net_cast$genes_and_modules |> 
  rename(gene = Genes, module = Modules)
network2 <- net_do$genes_and_modules |> 
  rename(gene = Genes, module = Modules)

comparison_results <- compare_networks(network1, network2)
comparison_results$adj_p_value <- p.adjust(comparison_results$p_value, method = "BH")

# Create the plot
plot_module_overlap(comparison_results, p_threshold = 0.01, highlight_modules = preserved_modules_cast_do)+
    labs(
      x = "CAST", 
      y = "DO"
      )

```
::::::::::::

# Gene regulatory network inference

I am using BioNero's `exp2grn` function to get a consensus network.
I obtained the TFs from the [TFcheckpoint website](https://www.tfcheckpoint.org/).
I am using the same gene set used in WGCNA for consistency.

Here is the description of the function from BioNero:

Inferring GRNs based on the wisdom of the crowds principle can be done with a single function: exp2grn().
This function will infer GRNs with GENIE3, ARACNE and CLR, calculate average ranks for each interaction and filter the resulting network based on the optimal scale-free topology (SFT) fit.
In the filtering step, n different networks are created by subsetting the top n quantiles.
For instance, if a network of 10,000 edges is given as input with nsplit = 10, 10 different networks will be created: the first with 1,000 edges, the second with 2,000 edges, and so on, with the last network being the original input network.
Then, for each network, the function will calculate the SFT fit and select the best fit.

::: {#GRN_results .panel-tabset .nav-pills}
## B6

```{r}
#| label: b6_grn_inf
#| eval: true
#| cache: true
#| fig-show: hide

regs <- intersect(unique(tfs$gene_id),wgcna_genes$gene_id)
b6_genie3 <- exp2grn(exp = b6_expr_final, 
                    regulators = regs, 
                    nTrees = 1000
                    )

```

B6 consensus network:

```{r}
#| label: plot_grn_b6
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plot_grn( edgelist_grn = b6_genie3, gene_annots = all_genes_palate, interactive = F, top_n_hubs = 15)


```

Let's plot interactively too: Too big!

```{r}
#| label: plot_grn_b6_int
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| eval: false

plot_grn( edgelist_grn = b6_genie3, gene_annots = all_genes_palate, interactive = T)


```

```{r}
#| label: grn_table_b6
#| warning: false
#| message: false

b6_grn_hubs <- get_hubs_grn(b6_genie3) # RN hubs are defined as the top 10% most highly connected regulators

b6_genie3 |> 
  left_join( b6_grn_hubs |> select( Regulator = Gene, Degree)) |> 
  left_join( all_genes_palate |> select(Regulator = gene_id, Regulator_symbol = symbol)) |> 
  left_join( all_genes_palate |> select(Target = gene_id, Target_symbol = symbol)) |> 
  mutate( Regulator_symbol = ifelse( is.na(Regulator_symbol), Regulator, Regulator_symbol)) |> 
  mutate( Target_symbol = ifelse( is.na(Target_symbol), Target, Target_symbol)) |> 
  select(-Regulator, -Target) |>
  mutate( hub = ifelse( is.na(Degree), "No", "Yes")) |> 
  select( Regulator = Regulator_symbol, Target = Target_symbol, `Is it a hub?`=hub, `Degree of connection`=Degree) |> 
  create_dt()

```

## CAST

```{r}
#| label: cast_grn_inf
#| eval: true
#| cache: true
#| fig-show: hide
regs <- intersect(unique(tfs$gene_id),wgcna_genes$gene_id)
cast_genie3 <- exp2grn(exp = cast_expr_final, 
                    regulators = regs,
                    nTrees = 1000
                    )



```

CAST consensus network:

```{r}
#| label: plot_grn_cast
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plot_grn( edgelist_grn = cast_genie3, gene_annots = all_genes_palate, interactive = F, top_n_hubs = 15)


```

Let's plot interactively too: Too big!

```{r}
#| label: plot_grn_cast_int
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| eval: false

plot_grn( edgelist_grn = cast_genie3, gene_annots = all_genes_palate, interactive = T)


```

```{r}
#| label: grn_table_cast
#| warning: false
#| message: false

cast_grn_hubs <- get_hubs_grn(cast_genie3) # RN hubs are defined as the top 10% most highly connected regulators

cast_genie3 |> 
  left_join( cast_grn_hubs |> select( Regulator = Gene, Degree)) |> 
  left_join( all_genes_palate |> select(Regulator = gene_id, Regulator_symbol = symbol)) |> 
  left_join( all_genes_palate |> select(Target = gene_id, Target_symbol = symbol)) |> 
  mutate( Regulator_symbol = ifelse( is.na(Regulator_symbol), Regulator, Regulator_symbol)) |> 
  mutate( Target_symbol = ifelse( is.na(Target_symbol), Target, Target_symbol)) |> 
  select(-Regulator, -Target) |>
  mutate( hub = ifelse( is.na(Degree), "No", "Yes")) |> 
  select( Regulator = Regulator_symbol, Target = Target_symbol, `Is it a hub?`=hub, `Degree of connection`=Degree) |> 
  create_dt()

```

## DO

```{r}
#| label: do_grn_inf
#| eval: true
#| cache: true
#| fig-show: hide

regs <- intersect(unique(tfs$gene_id),wgcna_genes$gene_id)
do_genie3 <- exp2grn(exp = do_expr_final, 
                    regulators = regs,
                    nTrees = 1000
                    )



```

DO consensus network is very big (\>100k interactions) !
I am not sure what is happening but will try and follow up.

```{r}
#| label: plot_grn_do
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plot_grn( edgelist_grn = do_genie3, gene_annots = all_genes_palate, interactive = F, top_n_hubs = 15)


```

Let's plot interactively too: Too big!

```{r}
#| label: plot_grn_do_int
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| eval: false

plot_grn( edgelist_grn = do_genie3, gene_annots = all_genes_palate, interactive = T)


```

The table is too big to display here as well.
I am getting \>100k interactions.

```{r}
#| label: grn_table_do
#| warning: false
#| message: false
#| eval: false

do_grn_hubs <- get_hubs_grn(do_genie3) # RN hubs are defined as the top 10% most highly connected regulators

do_genie3 |> 
  left_join( do_grn_hubs |> select( Regulator = Gene, Degree)) |> 
  left_join( all_genes_palate |> select(Regulator = gene_id, Regulator_symbol = symbol)) |> 
  left_join( all_genes_palate |> select(Target = gene_id, Target_symbol = symbol)) |> 
  mutate( Regulator_symbol = ifelse( is.na(Regulator_symbol), Regulator, Regulator_symbol)) |> 
  mutate( Target_symbol = ifelse( is.na(Target_symbol), Target, Target_symbol)) |> 
  select(-Regulator, -Target) |>
  mutate( hub = ifelse( is.na(Degree), "No", "Yes")) |> 
  select( Regulator = Regulator_symbol, Target = Target_symbol, `Is it a hub?`=hub, `Degree of connection`=Degree) |> 
  create_dt()

```
:::

# Using MEFISTO to identify temporal gene expression

```{r}
#| eval: false
#| label: mefisto_setup

library(MOFA2)
set.seed(2020)

# prep data to run mofa/mefisto on the interactive cluster
final_expr_all <- assay(dds_all_norm)[wgcna_genes$gene_id,,drop=F] |> 
 as_tibble( rownames = "feature") |> 
  pivot_longer( cols = 2:(ncol(assay(dds_all_norm))+1) , names_to = "sample",values_to = "value") |> 
  left_join(colData(dds_all_norm) |> 
              as_tibble() |> 
              select(sample = unique_sampleid, 
                     view = strain, 
                     domain = AP_domain, 
                     time = LB_stage)
             ) 

MOFAobject_untrained <- create_mofa(data = final_expr_all ) # using the same gene set as in WGCNA
plot_data_overview(MOFAobject_untrained)


MOFAobject_untrained <- set_covariates(MOFAobject_untrained, covariates = c("time"))

gg_input <- plot_data_overview(MOFAobject_untrained,
                               show_covariate = TRUE,
                               show_dimensions = TRUE) 
gg_input

data_opts <- get_default_data_options(MOFAobject_untrained)

model_opts <- get_default_model_options(MOFAobject_untrained)
model_opts$num_factors <- 10


train_opts <- get_default_training_options(MOFAobject_untrained)
train_opts$seed <- 2020
train_opts$convergence_mode <- "medium" # use "fast" for faster training

mefisto_opts <- get_default_mefisto_options(MOFAobject_untrained)
# mefisto_opts$warping <- TRUE
# mefisto_opts$warping_ref <- "B6"
# mefisto_opts$model_groups <- FALSE
# mefisto_opts$new_values <- 12:16 

MOFAobject_untrained <- prepare_mofa(
  object = MOFAobject_untrained,
  data_options = data_opts,
  model_options = model_opts,
  training_options = train_opts,
  mefisto_options = mefisto_opts
) 

save(MOFAobject_untrained, file = here("_data/mefisto_trial_untrained_model_strain_view_10factors.Rdata"))

# running on the interactive cluster using the docker container
outfile <- ("/projects/munger-lab/projects/palate-project-murray-munger/analysis/_data/mefisto_trial_strain_view_10factors.hdf5")
MOFAobject <- MOFA2::run_mofa(MOFAobject_untrained, outfile = outfile)

```

Here is what MEFISTO does from their [website](https://biofam.github.io/MOFA2/MEFISTO.html):

"MEFISTO provides an unsupervised approach to integrate multi-modal data with continuous structures among the samples, e.g. given by spatial or temporal relationships. The aim of MEFISTO is to exploit such relationships between samples in the dimensionality reduction and disentangle smooth sources of variation given by factors that change gradually along the covariate and other source of variation that are independent of the covariate. Furthermore, it enables to interpolate/extrapolate to unseen timepoints or locations.

If multiple groups of samples are present, e.g. timecourses from different individuals, MEFISTO furthermore models the heterogeneity of the temporal or spatial patterns across groups and allows to align timepoints across the groups in cases where there are no clear or imperfect correspondences between groups."

I ran MEFISTO with two different setting, I am displaying both results in tabs below since they each looked interesting.

1.  Using strains as group and time as covariate.
    In this setup, MEFISTO looks for sources of variation within groups hence doesn't compare the strains to each other.
    The use of groups allows us to align the developmental time points between the different strain backgrounds using B6 as the reference.

2.  Using strains as views and time as covariate.
    In this setup, MEFISTO identifies factors that separates the different strains.
    As you can see below, this leads to Factors 1-3 being highly correlated to time but explaining variation in each individual strain background.

I used over-representation analysis to functionally characterize each factor and included tables with factor weights for genes as well as plots so you can see the top drivers of each factor.

::: {#Mefisto_results .panel-tabset .nav-pills}
## Strains as group and time as covariate

Note from MOFA: The aim of the multi-group framework is to identify the sources of variability *within* the groups.
If your aim is to find a factor that 'separates' the groups, you DO NOT want to use the multi-group framework.

```{r}
#| label: load_trained_model_strain_only
#| eval: true
#| warning: false
#| message: false

library(MOFA2)
MOFAobject <- load_model( here("_data/mefisto_trial_just_strain_5factors.hdf5"), load_interpol_Z = TRUE)

sample_metadata <- colData(dds_all_norm) |> 
  as.data.frame() |> 
  select(sample = unique_sampleid,
         sex,
         domain = AP_domain,
         group = strain, 
         Palate_ori,
         time = LB_stage
         )

samples_metadata(MOFAobject) <- sample_metadata

var_exp <- get_variance_explained(MOFAobject)
# get factors
factors <- get_factors(MOFAobject,  factors = "all", scale = T, as.data.frame = T)
# get weights
weights <- get_weights(MOFAobject, views = "all", factors = "all", as.data.frame = T)


```

This is the data being inputted into MEFISTO:

```{r}
#| warning: false
#| message: false
plot_data_overview(MOFAobject,
                               show_covariate = TRUE,
                               show_dimensions = TRUE)
```

The MEFISTO model can capture variation across the three strains:

```{r}
p <- plot_variance_explained(MOFAobject, plot_total = T)
p[[2]] + theme(axis.text.x = element_text(angle = 90))
```

Individual factors capture variation at different amounts across strains:

```{r}
p[[1]] + theme(axis.text.x = element_text(angle = 90))

```

Looking at factors over time and across domains (unaligned):

```{r}
# Factors versus developmental time (before alignment)
plot_factors_vs_cov(MOFAobject, color_by = "group",shape_by = "domain",
                    covariate = "time",  warped = FALSE) 

```

Looking at factors over time and across domains aligned to B6:

```{r}
#| warning: false
#| message: false
# Factors versus developmental time (after alignment)
plot_factors_vs_cov(MOFAobject, color_by = "group",shape_by = "domain",
                    covariate = "time", scale = FALSE)
```

Aligned time points vs the reference (B6) time point for each strain:

```{r}
#| warning: false
#| message: false
plot_alignment(MOFAobject)
```

Are the factors shared across the groups (i.e. strains)?

```{r}
#| warning: false
#| message: false
#plot_group_kernel(MOFAobject, factors = "all")

plot_sharedness(MOFAobject) 
```

How are the factors correlated to the covariates in the data?
Displaying -lop10(pvalue).

```{r}
#| warning: false
#| message: false
factor_cov_cor <- correlate_factors_with_covariates(object = MOFAobject,
                                  covariates = sample_metadata,return_data = T)

factor_cov_cor |> 
  as_tibble( rownames = "Factor") |> 
  mutate_if( is.numeric, round, 2) |> 
  select(Factor, "LB stage" = time, "AP domain" = domain, sex) |> 
  create_dt()
```

Functional characterization of each factor using ORA:

```{r }
#| label: mefisto_module_ora
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
mefisto_ora_results <- c()

for( fac in unique(factors$factor)){
  
  facGenes <- weights |> 
    filter( factor == fac) |> 
    filter( abs(value) >= quantile(abs(value),.95)) |> 
    left_join(wgcna_genes, by =c("feature"="gene_id"))
  
  
  g.fac <- gost(query =  unique(facGenes$symbol),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = wgcna_genes$symbol,
                        evcodes = TRUE)
  mefisto_ora_results[[fac]] <- g.fac
}

```

```{r }
#| label: mefisto_ora_results_table
#| warning: false
#| message: false
#| eval: true
do.call( rbind, mefisto_ora_results) %>%
  as_tibble(rownames = "Factor") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(Factor,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```

Each factor value per sample:

```{r}
#| warning: false
#| message: false

factors |> 
  mutate( value = formatC(value, digits = 2, format = "e")) |> 
  create_dt()
```

Weights for each gene per factor:

```{r}
#| warning: false
#| message: false

weights |> 
  rename("gene_id" = "feature") |> 
  left_join( all_genes_palate |> select(gene_id, symbol)) |> 
  select( gene_id, symbol, factor, weight = value) |> 
  mutate( weight = formatC(weight, digits = 2, format = "e")) |> 
  create_dt()
```

## Strain as view and time as covariate

```{r}
#| label: load_trained_model_strain_views
#| eval: true
#| warning: false
#| message: false

library(MOFA2)
MOFAobject2 <- load_model( here("_data/mefisto_trial_strain_view_5factors.hdf5"))

sample_metadata <- colData(dds_all_norm) |> 
  as.data.frame() |> 
  select(sample = unique_sampleid,
         sex,
         domain = AP_domain,
         view = strain, 
         Palate_ori,
         time = LB_stage
         )

samples_metadata(MOFAobject2) <- sample_metadata

var_exp2 <- get_variance_explained(MOFAobject2 )
# get factors
factors2 <- get_factors(MOFAobject2,  factors = "all", scale = T, as.data.frame = T)
# get weights
weights2 <- get_weights(MOFAobject2, views = "all", factors = "all", as.data.frame = T)

```

This is the data being inputted into MEFISTO:

```{r}
#| warning: false
#| message: false
plot_data_overview(MOFAobject2,
                               show_covariate = TRUE,
                               show_dimensions = TRUE)
```

The MEFISTO model can capture variation across the three strains:

```{r}
#| warning: false
#| message: false
p <- plot_variance_explained(MOFAobject2, plot_total = T)
p[[2]] + theme(axis.text.x = element_text(angle = 90))

```

Individual factors capture variation at different amounts across strains:

```{r}
#| warning: false
#| message: false
p[[1]] + theme(axis.text.x = element_text(angle = 90))
```

Looking at factors over time and across domains:

```{r}
#| warning: false
#| message: false
# Factors versus developmental time 
plot_factors_vs_cov(MOFAobject2, color_by = "view",shape_by = "domain",
                    covariate = "time",  warped = FALSE) 
```

How are the factors correlated to the covariates in the data?
Displaying -lop10(pvalue).

```{r}
#| warning: false
#| message: false
factor_cov_cor2 <- correlate_factors_with_covariates(object = MOFAobject2,
                                  covariates = sample_metadata,return_data = T)

factor_cov_cor2 |> 
  as_tibble( rownames = "Factor") |> 
  mutate_if( is.numeric, round, 2) |> 
  select(Factor, "LB stage" = time, "AP domain" = domain, sex) |> 
  create_dt()
```

Functional characterization of each factor using ORA:

```{r }
#| label: mefisto_module_ora2
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
mefisto_ora_results2 <- c()

for( fac in unique(factors2$factor)){
  
  facGenes <- weights2 |>
    filter( factor == fac) |> 
    group_by( view) |> 
    filter( abs(value) >= quantile(abs(value),.95)) |> 
    mutate( gene_id = gsub( paste0("_",view), "",feature)) |> 
    left_join(wgcna_genes)
  
  
  g.fac_b6 <- gost(query =  (facGenes |> filter( view == "B6"))$symbol,
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = wgcna_genes$symbol,
                        evcodes = TRUE)
  
  g.fac_cast <- gost(query =  (facGenes |> filter( view == "CAST"))$symbol,
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = wgcna_genes$symbol,
                        evcodes = TRUE)
  g.fac_do <- gost(query =  (facGenes |> filter( view == "DO"))$symbol,
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = wgcna_genes$symbol,
                        evcodes = TRUE)
      
  mefisto_ora_results2[[paste0(fac,"_B6")]] <- g.fac_b6
  mefisto_ora_results2[[paste0(fac,"_CAST")]] <- g.fac_cast
  mefisto_ora_results2[[paste0(fac,"_DO")]] <- g.fac_do
  
}

```

```{r }
#| label: mefisto_ora_results_table2
#| eval: true
#| warning: false
#| message: false

do.call( rbind, mefisto_ora_results2) %>%
  as_tibble(rownames = "Factor") %>%
  separate( Factor, into = c("Factor","Strain"), sep = "_") |> 
  select(-meta) %>%
  unnest("result") %>%
  select(Factor, Strain, term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```

Each factor value per sample:

```{r}
#| warning: false
#| message: false

factors2 |> 
  mutate( value = formatC(value, digits = 2, format = "e")) |> 
  select(-group) |> 
  create_dt()

```

Weights for each gene per factor:

```{r}
#| warning: false
#| message: false

weights2 |> 
  separate(feature, into= c("gene_id","strain"), sep = "_") |> 
  left_join( all_genes_palate |> select(gene_id, symbol)) |> 
  select( gene_id, symbol, factor, view, weight = value) |> 
  mutate( weight = formatC(weight, digits = 2, format = "e")) |> 
  create_dt()

```

<!-- ## Strains as group, domains as view and time as covariate -->

<!-- Note from MOFA: The aim of the multi-group framework is to identify the sources of variability *within* the groups. If your aim is to find a factor that 'separates' the groups, you DO NOT want to use the multi-group framework.  -->

<!-- ```{r} -->

<!-- #| label: load_trained_model_strain_and_domain -->

<!-- #| eval: true -->

<!-- #| warning: false -->

<!-- #| message: false -->

<!-- MOFAobject2 <- load_model( here("_data/mefisto_trial_strain_and_domain_5Factors.hdf5"), load_interpol_Z = TRUE) -->

<!-- samples_metadata(MOFAobject2) <- sample_metadata -->

<!-- # plot_data_overview(MOFAobject2, -->

<!-- #                                show_covariate = TRUE, -->

<!-- #                                show_dimensions = TRUE) -->

<!-- p <- plot_variance_explained(MOFAobject2, plot_total = T) -->

<!-- p[[1]] + theme(axis.text.x = element_text(angle = 90)) -->

<!-- p[[2]] + theme(axis.text.x = element_text(angle = 90)) -->

<!-- # Factors versus developmental time (before alignment) -->

<!-- plot_factors_vs_cov(MOFAobject2, color_by = "group", -->

<!--                     covariate = "time",  warped = FALSE)  -->

<!-- # Factors versus developmental time (after alignment) -->

<!-- plot_factors_vs_cov(MOFAobject2, color_by = "group", -->

<!--                     covariate = "time", scale = FALSE) -->

<!-- plot_interpolation_vs_covariate(MOFAobject2, only_mean = FALSE) -->

<!-- plot_factors(MOFAobject2, 1:5, color_by = "time")  -->

<!-- plot_alignment(MOFAobject2) -->

<!-- plot_group_kernel(MOFAobject2, factors = "all") -->

<!-- plot_sharedness(MOFAobject2)  -->

<!-- correlate_factors_with_covariates(object = MOFAobject2, covariates = sample_metadata) -->

<!-- ``` -->
:::
