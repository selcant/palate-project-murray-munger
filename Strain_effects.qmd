---
title: "Investigating strain and developmental stage effects"
author: "Selcan Aydin"
date: "`r Sys.Date()`"
format: 
  html:
      embed-resources: true
      standalone: true
include-in-header:
  - text: |
      <style>
      .panel-tabset > .nav-tabs,
      .panel-tabset > .tab-content {
        border: none;
      }
      </style>
code-fold: true
toc: true
toc-depth: 5
toc-expand: true
editor: 
  markdown: 
    wrap: sentence
comments:
  hypothesis: 
    theme: clean
---

```{r setup}
#| message: false
#| warning: false

knitr::opts_chunk$set(message = NA, warning = NA)
# load packages
suppressPackageStartupMessages(library(tidyverse))

library(pheatmap)
library(plotly)
library(GGally)
library(ggpubr)
library(ggplot2)
library(corrplot)
library(simplifyEnrichment)

library(DESeq2)
library(DEGreport)
library(gprofiler2)
set_base_url("https://biit.cs.ut.ee/gprofiler_archive3/e108_eg55_p17/")
library(BioNERO)
set.seed(123) # for reproducibility
# library(WGCNA)

library(DT)

library(here)

select <- dplyr::select # I am adding this explicitly
rename <- dplyr::rename # I am adding this explicitly
filter <- dplyr::filter # I am adding this explicitly
summarize <- dplyr::summarize # I am adding this explicitly

# functions
create_dt <- function(x){
  DT::datatable(x,
                extensions = 'Buttons',
                rownames = FALSE, 
                filter="top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel'),
                               pageLength = 5, 
                               scrollX= TRUE
                               ))
  
}

# reading in the sample details
sample_details <- read_csv("/projects/munger-lab/projects/palate-project-murray-munger/samplesheet.csv") 

# domain colors
domain_colors <- c(PM=rgb(252,206,93, maxColorValue = 255), 
                   MAX=rgb(163,82,157, maxColorValue = 255), 
                   POST=rgb(158,156,201, maxColorValue = 255)
                   )

# strain colors
strain_colors <- c( B6 = "#555555", 
                    CAST = "#009E73",
                    DO = rgb(163,82,157, maxColorValue = 255))




```

```{r load_data_emase}
#| message: false
#| warning: false

# loading the count data
load("/projects/munger-lab/projects/palate-project-murray-munger/read_mapping/palate_gbrs_emase_counts_v4.RData") # raw_expr_mat, expr_mat_do, expr_mat_nondo 
expr_mat <- expr_mat_nondo
contam_samples <- c("B6_12.5_PM_1","B6_13.5_POST_3", "CAST_14.5_MAX_7", "B6_13.5_MAX_3")
expr_mat <- expr_mat[ ,!colnames(expr_mat) %in% contam_samples]
do_expr_mat <- expr_mat_do
remove_samples <- c("DO_13.5_MAX_6", "DO_13.5_MAX_14", "DO_13.5_MAX_14_2",
                    "DO_12.5_MAX_1" , "DO_12.5_MAX_2" ,"DO_13.5_MAX_97", "DO_13.5_MAX_96") # 96 & 97 are also 12.5 samples
do_expr_mat <- do_expr_mat[ ,!colnames(do_expr_mat) %in% remove_samples]

expr_mat_all <- cbind( expr_mat[intersect(rownames(expr_mat),rownames(do_expr_mat)),,drop=F],
                       do_expr_mat[intersect(rownames(expr_mat),rownames(do_expr_mat)),,drop=F])
rm(expr_mat_do, expr_mat_nondo)

# Get v105 annotations from biomart
all.genes_v105 <- read_tsv(here("_data","ENSMUSGid_to_symbol_v105.txt"),
                           col_names = c("gene_id","symbol","gene_biotype","chromosome","start","end"), skip =1) |>  
  mutate(midpoint = (start+end)/2)

all_genes_palate <- all.genes_v105 %>%
  filter(gene_id %in% rownames(raw_expr_mat))

# sample annotations
sample_annot <- sample_details %>% 
  #as_tibble( rownames = "sample") |> 
  filter( !sample %in% contam_samples & sample %in% colnames(expr_mat)) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure, L_R_palate) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) |> 
  mutate( LB_stage_binned = case_when(
    ( LB_stage < 12.25 )~"exclude",
    (between(LB_stage, 13.25, 13.5))~"exclude",
    (between(LB_stage, 12.25,12.75))~"1",
    (between(LB_stage, 13.5, 14))~"2",
    (between(LB_stage, 14.25, 14.75))~"3",
    (between(LB_stage, 15.1, 15.6))~"4"
  )) |> 
  mutate( LB_stage_binned = as_factor(LB_stage_binned)) |> 
  separate( L_R_palate, into = c("temp","Palate_ori" ), sep = "_") |> 
  select(-temp) |> 
  mutate( Palate_ori = ifelse( Palate_ori == "L", "Left","Right")) 
  

sample_annot_all <- sample_details %>% 
  #as_tibble( rownames = "sample") |> 
  filter( !sample %in% contam_samples & sample %in% colnames(expr_mat_all)) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure,L_R_palate) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) |> 
  separate( L_R_palate, into = c("temp","Palate_ori" ), sep = "_") |> 
  select(-temp) |> 
  mutate( Palate_ori = ifelse( Palate_ori == "L", "Left","Right"))

# Genes from Ian:
pheno_gene_list <- readxl::read_xlsx(here("_data","Supp6_BoneGeneList.xlsx")) |> 
  select( symbol = gene_name) |> 
  distinct() |> 
  mutate(type = "pheno", type_long = "bone phenotype gene list (Sabik et al 2020, Table S6)")

skeletal_gene_table <- readxl::read_xlsx(here("_data","Skeletal_stem_progenitor_markers.xlsx")) |> 
  dplyr::rename("symbol" = "gene") |> 
  mutate(type = "MSC", type_long = "MSC/skeletal progenitor markers")

figure_genes <- c(MSC =c("Axin2","Gli1","Meis2","Lepr","Prrx1"),
           skeletal = c("Sox9","Runx2","Sp7","Nfatc1","Bcl11b","Msx2","Msx1","Egr1","Egr2"),
           osteoclast = c("Spi1","Tnfsf11","Tnfrsf11","PParg","Fos","Junb","Csf1","Csf1r","Ostf1",
                          "Acp5","Mmp9","Ctsk","Timp1","Atp6v0d2","Adgre1","Sfrp4","Dcstamp","Ocstamp","Htra1","Tcirg1","Itgb3","Gnptab"),
           osteoblast = c("Alpl","Ibsp","Phospho1","Vdr","Sparc","Panx3","Enpp1","Bglap","Bglap2","Clecl11a","Sost","Dmp1","Col1a1","Col1a2","Bgn","Dcn","Thbs2")
           
           ) |> 
  as_tibble(rownames = "type" ) |> 
  rename( symbol = value  ) |> 
  mutate(type = gsub("[0-9]","",type)) |> 
  mutate( type_long = case_when(type =="MSC"~"MSC/skeletal progenitor markers",
                                type =="skeletal"~"Skeletal speciation markers",
                                type =="osteoclast"~"Osteoclast markers",
                                type =="osteoblast"~"osteoblast/osteocyte markers"
                                )) 

morpho_genes <- readxl::read_xlsx(path = here("_data","abnormal craniofacial morphology-MGIBatchReport.xlsx")) |> 
  select(symbol = Symbol, mgi_id = `MGI Gene/Marker ID`, gene_biotype = `Feature Type`) 

# add gene names to MGI ids for genes
# checked the overlap
# length(intersect(mgi_id_annots$symbol, all_genes_palate$symbol)) # 16958/17146
# most of the missing ones are RPXX-YY genes or Gms
mgi_id_annots <- read_delim( file = here("_data","MRK_List1.rpt"),
                             #MGI Marker Accession ID	Chromosome	cM Position	Genome Coordinate Start	Genome Coordinate End	Genome Strand	Marker Symbol	Status	Marker Name	Marker Type	Feature Types (|-delimted)	Marker Synonyms (|-delimited)
                             col_names = c("mgi_id",
                                           "chromosome",
                                           "pos_cM",
                                           "start",
                                           "end",
                                           "strand",
                                           "symbol",
                                           "status",
                                           "marker_name",
                                           "marker_type",
                                           "feature_types",
                                           "marker_synms"), skip = 1) 

# getting the gene list for mammalian phenotypes
mp_genes <- read_delim( file = here("_data","MGI_PhenoGenoMP.rpt"),
                        # Allelic Composition	Allele Symbol(s)	Genetic Background	Mammalian Phenotype ID	PubMed ID	MGI Marker Accession ID (comma-delimited)
                        col_names = c("allelic_comp",
                                      "allele_symbol",
                                      "genetic_background",
                                      "mp_id",
                                      "pubmed_id",
                                      "mgi_id")) |> 
  select(mp_id, mgi_id) |> 
  distinct() |> 
  separate_longer_delim( mgi_id, delim = "|") |> 
  left_join(mgi_id_annots |> 
              select(mgi_id, symbol)) 
# add mammalian phenotype definitions
mp_defs <- read_delim( file = here("_data","VOC_MammalianPhenotype.rpt"),
                       col_names = c("mp_id","term_name","term_details")) 



genes <- full_join( figure_genes, skeletal_gene_table ) |> 
  #full_join( pheno_gene_list) |> 
  left_join(all_genes_palate)
# 
# genes |> 
#   group_by(symbol) |> 
#   mutate(n = n()) |> 
#   filter(n > 1) |> 
#   arrange(symbol)

```

This notebook is analyzing the palate gene expression from different genetic backgrounds, AP domains obtained at various gestational stages.
The first section uses the normalized gene expression counts from DO, B6 and CAST mice to look at sources of variation.
The second section focuses on B6 and CAST gene expression to specifically identify differentially expressed genes across domains, gestational stages and strain backgrounds.
Finally, the third section performs weighted gene co-expression network analysis using the gene expression data from B6 and CAST strains.
The genetic characterization of gene expression and developmental phenotypes using the DO strains can be found in `Palate_qtl_mapping.html` notebook.

```{r save_data_for_ian}
#| warning: false
#| message: false
#| eval: false
# loading the count data
load("/projects/munger-lab/projects/palate-project-murray-munger/read_mapping/palate_gbrs_emase_counts_v3.RData") # raw_expr_mat, expr_mat_do, expr_mat_nondo 

sample_annot <- sample_details %>% 
  filter( !sample %in% contam_samples ) %>% 
  separate(Strain_stock, into = c("strain","tmp"), remove = F, sep = "_") %>% 
  select(sample,sex, AP_domain,Gest_stage, strain,batch, Harvest_date,LB_stage, palate_closure) %>% 
  mutate( strain = case_when(strain =="B6J"~"B6",
                             strain !="B6J"~strain)) 

expr_mat <- expr_mat_do |> 
  as_tibble(rownames = "gene_id") |> 
  full_join(
    expr_mat_nondo |> 
      as_tibble(rownames = "gene_id")
  ) |> 
  #select( any_of(c("gene_id",sample_annot$sample))) |> 
  column_to_rownames("gene_id") |> 
  as.matrix()

list( "normalized_gene_counts" = as_tibble(expr_mat[,sample_annot$sample,drop=F], rownames = "gene_id"),
      "raw_gene_counts" = as_tibble(raw_expr_mat[,sample_annot$sample,drop=F], rownames = "gene_id") ,
     "sample_annotations"=sample_annot,
     "gene_annotations" = all_genes_palate
     ) %>%
  openxlsx::write.xlsx(., file = here("_data","Gene_counts_for_Ian_12052023.xlsx"))

note <- paste0("Data saved on ", Sys.Date(), " by SA in rstudio Strain effects.qmd script.")
expr_mat <- expr_mat[,sample_annot$sample,drop=F]
raw_expr_mat <- raw_expr_mat[,sample_annot$sample,drop=F]
save( expr_mat,
      raw_expr_mat,
      sample_annot,
      all_genes_palate,
      note,
      file = here("_data","Gene_counts_for_Ian_12052023.RData")
     )

# downloadthis::download_file(
#   path = system.file(here("_data","Gene_counts_for_Ian_10162023.xlsx"),
#                           package = "downloadthis"),
#   output_name = "Gene counts for Ian",
#   button_label = "Download gene counts",
#   button_type = "primary",
#   has_icon = TRUE,
#   icon = "fa fa-save",
#   self_contained = FALSE
# )

pca <- prcomp( t( log1p( expr_mat[,sample_annot$sample,drop = F])), center = T, scale = F)
pca_df <- as_tibble(pca$x, rownames = "sample") %>% 
  left_join(sample_annot)
var_explained <- (pca$sdev^2 / sum(pca$sdev^2))
note <- paste0("Data saved on ", Sys.Date(), " by SA in rstudio Strain effects.qmd script.")
# saving RData files so he can run PCA and other things
save(
  pca,
  pca_df,
  var_explained,
  expr_mat,
  sample_annot,
  all_genes_palate,
  note,
  file = here("_data","Data_for_Ian_01302024.RData")
)

```

# Principal component analysis

Raw data was processed as follows:

-   Genes with a median transcript per million (TPM) lower than 0.5 were filtered while samples were grouped by gestational stage.
    The grouping is necessary because there are uniquely expressed genes in each stage.

-   Counts were normalized using variance stablizing transformation as implemented in DESeq2::vst() function..

In the final data set we have `r formatC(nrow(expr_mat_all), big.mark=",")` genes expressed across `r nrow(sample_annot_all)` samples.

Brief summary of PCA results:

-   First principal component (PC) groups samples by developmental time.

-   Second PC groups samples by strain background.

-   Fourth PC groups samples by AP domain.

-   PC5 and PC6 are highlighting a few DO samples that are highly similar to each other but differ from the rest of the samples.
    In the DO data, PC1 and PC2 separates these same samples from the rest of the DO samples.

-   PC7 groups samples based on sex.

```{r pca_b6_cast_do}
#| message: false
#| warning: false

# raw_colData <- sample_annot %>%
#   separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
#   select(-e,-d) %>%
#   mutate( rep = ifelse( is.na(rep),1,rep)) %>%
#   unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) %>%
#   select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage) %>%
#   filter(!is.na(sex) ) %>%
#   mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
#   column_to_rownames("sample")
# 
# raw_dds <- DESeqDataSetFromMatrix(countData = round(raw_expr_mat[,sample_annot$sample, drop = F]),
#                                   colData = sample_annot,
#                                   design = ~1)
# raw_dds_vst <- varianceStabilizingTransformation(raw_dds)
# assay(raw_dds, "vst") <- assay(raw_dds_vst)
# 
# pca <- prcomp(t(assay(raw_dds, "vst")), center=TRUE, scale=FALSE)


pca <- prcomp( t( log1p( expr_mat_all)), center = T, scale = F)
pca_df <- as_tibble(pca$x, rownames = "sample") %>% 
  left_join(sample_annot_all)
var_explained <- (pca$sdev^2 / sum(pca$sdev^2))

```

```{r pca_ora}
#| cache: true
#| message: false
#| warning: false

# pc drivers
pc1_drivers <- pca$rotation[,"PC1", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC1) >= quantile(abs(PC1), 0.95))

pc2_drivers <- pca$rotation[,"PC2", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC2) >= quantile(abs(PC2), 0.95))

pc3_drivers <- pca$rotation[,"PC3", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC3) >= quantile(abs(PC3), 0.95))

pc4_drivers <- pca$rotation[,"PC4", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC4) >= quantile(abs(PC4), 0.95))

pc5_drivers <- pca$rotation[,"PC5", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC5) >= quantile(abs(PC5), 0.95))

pc6_drivers <- pca$rotation[,"PC6", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC6) >= quantile(abs(PC6), 0.95))

pc7_drivers <- pca$rotation[,"PC7", drop = FALSE] %>% 
  as_tibble( rownames = "gene_id") %>% 
  left_join( all.genes_v105 %>%  
               select(gene_id, symbol)
             ) %>% 
  filter( abs(PC7) >= quantile(abs(PC7), 0.95))


# ORA with pc drivers 1-5
# background


g.pc1 <- gost(
  query = pc1_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
g.pc1$result <- g.pc1$result %>% filter(term_size < 660)

g.pc2 <- gost(
  query = pc2_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
g.pc2$result <- g.pc2$result %>% filter(term_size < 660)

g.pc3 <- gost(
  query = pc3_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
if(length(g.pc3$result) >1) g.pc3$result <- g.pc3$result %>% filter(term_size < 660)

g.pc4 <- gost(
  query = pc4_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all_genes_palate$symbol,
  evcodes = TRUE
)
if(length(g.pc4$result) >1) g.pc4$result <- g.pc4$result %>% filter(term_size < 660)

g.pc5 <- gost(
  query = pc5_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all.genes_v105$symbol,
  evcodes = TRUE,
  correction_method = "fdr"
)
if(length(g.pc5$result) >1) g.pc5$result <- g.pc5$result %>% filter(term_size < 660)

g.pc6 <- gost(
  query = pc6_drivers$symbol,
  organism = "mmusculus",
  domain_scope = "custom",
  custom_bg = all.genes_v105$symbol,
  evcodes = TRUE,
  correction_method = "fdr"
)
if(length(g.pc6$result) >1) g.pc6$result <- g.pc6$result %>% filter(term_size < 660)


```

::: {#PCs .panel-tabset .nav-pills}
## Looking at first 10 PCs

By strain:

```{r first_five_pcs_emase_strain}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  left_join(sample_annot_all) %>%
  ggpairs(.,
    columns = 2:11, progress = FALSE, ggplot2::aes(color = strain, shape =strain),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  scale_color_manual( values = strain_colors)+
  scale_fill_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond", DO="square"))+
  # color_palette("npg")+
  # fill_palette("npg")+
  theme(legend.position = "right")

```

By gestational stage:

```{r first_five_pcs_emase_gest}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  left_join(sample_annot_all) %>%
  ggpairs(.,
    columns = 2:11, progress = FALSE, ggplot2::aes(shape = strain, color =Gest_stage),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  # scale_color_manual( values = strain_colors)+
  # scale_fill_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  scale_color_viridis_d()+
  scale_fill_viridis_d()+
  theme(legend.position = "right")

```

By sex:

```{r first_five_pcs_emase_sex}
#| message: false
#| warning: false
#| fig-width: 14
#| fig-height: 14

pca$x %>%
  as_tibble(rownames = "sample") %>% 
  left_join(sample_annot_all) %>%
  ggpairs(.,
    columns = 2:11, progress = FALSE, ggplot2::aes(shape = strain, color =sex),
    upper = list(continuous = "density", combo = "box_no_facet"),
    lower = list(continuous = "points", combo = "dot_no_facet")
  ) + 
  theme_pubclean(base_size = 14) +
  # scale_color_manual( values = strain_colors)+
  # scale_fill_manual( values = strain_colors)+
  # scale_color_viridis_d()+
  # scale_fill_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  color_palette("npg")+
  fill_palette("npg")+
  theme(legend.position = "right")

```

Variation explained:

```{r scree_plot_emase}
#| message: false
#| warning: false
#| fig-width: 5
#| fig-height: 4

tibble(var =  var_explained[1:10]* 100, PC = paste0("PC", seq(1:10))) %>%
  arrange(desc(var)) %>%
  mutate(label = factor(PC, levels = PC)) %>%
  ggplot(aes(x = label, y = var)) +
  geom_col() +
  xlab("Principal Component") +
  ylab("% Variation explained") +
  theme_pubclean(base_size = 14)+
  ylim(0,25)


```

## PC1, PC2 and PC4

```{r pc123_3dplot}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

fig <- plot_ly(pca_df, 
               x = ~PC1, 
               y = ~PC2, 
               z = ~PC4,
               symbol = ~strain,
               symbols = c("circle","diamond","square"),
               text = ~sample,
               color = ~strain,
               colors = strain_colors,
               mode = "markers",
               type = "scatter3d"
)
fig <- fig %>% 
  layout(scene = list(xaxis = list(title = paste0("PC1 (",100*round(var_explained[1],2),"%)")),
                                   yaxis = list(title = paste0("PC2 (",100*round(var_explained[2],2),"%)")),
                                   zaxis = list(title = paste0("PC4 (",100*round(var_explained[4],2),"%)")))
)

fig

```

```{r pc123_3dplot_dom}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

fig <- plot_ly(pca_df, 
               x = ~PC1, 
               y = ~PC2, 
               z = ~PC4,
               color = ~AP_domain,
               symbol = ~strain,
               symbols = c("circle","diamond","square"),
               text = ~sample,
               colors = c(domain_colors),
               mode = "markers",
               type = "scatter3d"
)
fig <- fig %>% 
  layout(scene = list(xaxis = list(title = paste0("PC1 (",100*round(var_explained[1],2),"%)")),
                                   yaxis = list(title = paste0("PC2 (",100*round(var_explained[2],2),"%)")),
                                   zaxis = list(title = paste0("PC4 (",100*round(var_explained[4],2),"%)")))
)

fig

```

## PC1 groups samples by developmental time

```{r pc1_pc2_emase}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC1, 
       y = PC2,
       col = Gest_stage,
       shape = strain,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  #scale_color_manual( values = strain_colors)+
  scale_color_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  ylab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  theme(legend.position = "right")+
  labs(shape = "strain",
       col = "Gestational\nstage")


ggplotly(pca_plot, tooltip = c("label"))

```

```{r pc1_pc2_emase_lb}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC1, 
       y = PC2,
       shape = strain,
       #shape = Gest_stage,
       col = LB_stage,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  scale_color_viridis_c(limits = c(12,16))+
  #scale_color_manual(values=strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  ylab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  theme(legend.position = "right")+
  labs(color = "Limb bud\nstage",
       shape = "Strain")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC1 driver genes:

```{r pc1_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc1)

```

```{r pc1_ora_table}
#| message: false
#| warning: false


g.pc1$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%  # intersecion: adding the list of genes identified as overlapping with each category
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC1 driver genes:

```{r pc1_gene_table}
#| message: false
#| warning: false


pc1_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC1))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC2 groups samples by strain

```{r pc2_pc1_strain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC2, 
       y = PC1,
       col = strain,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  scale_color_viridis_d()+
  #color_palette("npg")+
  scale_color_manual( values = strain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC2 (",100*round(var_explained[2],2),"%)"))+
  ylab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC2 driver genes:

```{r pc2_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc2, capped = F)

```

```{r pc2_ora_table}

g.pc2$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC2 driver genes:

```{r pc2_gene_table}
#| message: false
#| warning: false


pc2_drivers %>% 
    left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC2))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC3 and PC4 group samples by domain

```{r pc4_pc3_domain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC3, 
       y = PC4,
       col = AP_domain,
       shape = strain,
       label = sample,
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #scale_color_viridis_c(limits = c(12,16))+
  scale_color_manual(values = domain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC4 (",100*round(var_explained[4],2),"%)"))+
  xlab(paste0("PC3 (",100*round(var_explained[3],2),"%)"))+
  theme(legend.position = "right")+
  labs(color = "AP domain",
       shape = "Strain")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC3 driver genes:

```{r pc3_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc3, capped = T)

```

```{r pc3_ora_table}
#| eval: true
g.pc3$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC3 driver genes:

```{r pc3_gene_table}
#| message: false
#| warning: false


pc3_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC3))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```


```{r pc1_pc4_domain}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  ggplot()+
  aes( x = PC4, 
       y = PC1,
       col = AP_domain,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  scale_color_manual( values = domain_colors)+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  xlab(paste0("PC4 (",100*round(var_explained[4],2),"%)"))+
  ylab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

ORA results for PC4 driver genes:

```{r pc4_ora_plot}
#| message: false
#| warning: false
#| eval: true
gostplot(g.pc4, capped = T)

```

```{r pc4_ora_table}

g.pc4$result %>% 
  select( term_name, source, FDR = p_value, term_size, intersection_size, intersection) %>% 
  filter( FDR <0.05) %>% 
  mutate_if( is.numeric, formatC, digits =2) %>% 
  create_dt()

```

Table with the full list of PC4 driver genes:

```{r pc4_gene_table}
#| message: false
#| warning: false


pc4_drivers %>% 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  arrange(desc(abs(PC4))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC5 identifies outliers

```{r pc5_pc6}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>%
  filter( !is.na(sex)) %>%
  ggplot()+
  aes( x = PC1,
       y = PC5,
       col = LB_stage,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  #color_palette("npg")+
  scale_color_viridis_c(limits = c(12,16))+
  scale_shape_manual( values = c(B6="circle",CAST="diamond",DO="square"))+
  ylab(paste0("PC5 (",100*round(var_explained[5],2),"%)"))+
  xlab(paste0("PC1 (",100*round(var_explained[1],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

Table with the full list of PC5 driver genes:

```{r pc56_gene_table}
#| message: false
#| warning: false


pc5_drivers %>% 
  mutate(PC = "PC5") |> 
  dplyr::rename( "value" = "PC5") |> 
  # rbind(
  #   pc6_drivers |> 
  #     mutate(PC = "PC6") |> 
  #     dplyr::rename("value" = "PC6")
  # ) |> 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```

## PC6 and PC7 group samples by sex

```{r pc7_pc1}
#| message: false
#| warning: false
#| fig-width: 8
#| fig-height: 6

pca_plot <- pca_df %>% 
  filter( !is.na(sex)) %>% 
  ggplot()+
  aes( x = PC7, 
       y = PC6,
       col = sex,
       shape = strain,
       label = sample
       )+
  geom_point(size = 4, alpha = 0.7)+
  theme_pubclean()+
  color_palette("npg")+
  #scale_color_viridis_d()+
  scale_shape_manual( values = c(B6="circle",CAST="diamond"))+
  ylab(paste0("PC6 (",100*round(var_explained[6],2),"%)"))+
  xlab(paste0("PC7 (",100*round(var_explained[7],2),"%)"))+
  theme(legend.position = "right")


ggplotly(pca_plot, tooltip = c("label"))

```

Table with the full list of PC6 and PC7 driver genes:

```{r pc7_gene_table}
#| message: false
#| warning: false


pc6_drivers %>% 
  mutate(PC = "PC6") |> 
  dplyr::rename("value" = "PC6") |> 
  left_join(
    all_genes_palate %>% 
      select(symbol, chromosome)
  ) %>% 
  rbind(
    pc7_drivers |>
      mutate(PC = "PC7") |>
      dplyr::rename("value" = "PC7") |> 
      left_join(
        all_genes_palate %>% 
          select(symbol, chromosome))
  ) |>
  #arrange(desc(abs(PC7))) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  create_dt()

```
:::

# Gene set variation analysis

Add GSVA here with:

-   GO BP

-   MGI mammalian phenotypes


```{r run_gsva}
#| warning: false
#| message: false
#| results: hide
#| cache: true

# reading in the GO + mgi downloaded from: http://www.informatics.jax.org/gotools/data/input/MGIgenes_by_GOid.txt
go_terms <- read_tsv( "http://www.informatics.jax.org/gotools/data/input/MGIgenes_by_GOid.txt") %>% 
  mutate( genes = str_split(genes, ",")) %>% 
  unnest() # separete the symbols, note the overlap: length(intersect(unique(go_terms$genes), npc.genes$mgi_symbol) ) = 11806


slim_go_terms <- read_tsv( "http://www.informatics.jax.org/gotools/data/input/map2MGIslim.txt") %>% 
  select(-term) %>% 
  mutate( ONT = case_when( aspect == "P" ~  "BP",
                     aspect == "F" ~ "MF",
                     aspect == "C" ~ "CC"
                     )
          ) %>% 
  select(-aspect)

genesbygo <- split(go_terms$genes, go_terms$GO_id)

go_terms_annot <- go_terms %>%  
  select(GO_id) %>% 
  distinct() %>% 
  left_join( slim_go_terms %>%  select( GO_id, ONT) %>% distinct())

goannot_wdef <- AnnotationDbi::select(GO.db::GO.db, keys= unique(go_terms$GO_id), columns=c("GOID","DEFINITION","ONTOLOGY","TERM")) %>%
  left_join( slim_go_terms, by=c("GOID"="GO_id")) %>% 
  mutate( ONTOLOGY = ONT) %>% 
  select(-ONT)

go_bp <- goannot_wdef %>% filter( ONTOLOGY == "BP") %>% 
  select(GOID) %>%  distinct()

# adding mammalian phenotypes!
genesbyMP <- split(mp_genes$symbol, mp_genes$mp_id)

# expr - change gene id's to symbols for GSVA with GO
expr.upd <- expr_mat[all_genes_palate$gene_id,]
rownames(expr.upd) <- all_genes_palate$symbol

# run gsva
gsva_go <- GSVA::gsva(  expr = expr.upd,
                   gset.idx.list = genesbygo,
                    method ="gsva",
                    kcdf = "none",
                    min.sz = 5,
                    max.sz = 1000,
                    mx.diff = TRUE
                   )

gsva_mp <- GSVA::gsva(  expr = expr.upd,
                   gset.idx.list = genesbyMP,
                    method ="gsva",
                    kcdf = "none",
                    min.sz = 5,
                    max.sz = 5000, # setting to 1000 only removes 6 gene sets
                    mx.diff = TRUE
                   )

# following up on rna results
gsva_go %>% 
  as_tibble(rownames = "Category") %>% 
  filter( Category %in% go_bp$GOID) %>% #filtering for BP
  rbind( gsva_mp |> 
           as_tibble( rownames = "Category")) |> 
  pivot_longer( cols = colnames(expr.upd),
                values_to = "Enrichment_Score",
                names_to = "sample") %>% 
  # add covariates 
  left_join( sample_annot %>% 
               select(sample, sex, strain, AP_domain,LB_stage_binned)) -> gsva_results

gsva_results %>% 
  group_by( Category) %>% 
  rstatix::anova_test( Enrichment_Score ~ strain+AP_domain+LB_stage_binned) %>% 
  rstatix::adjust_pvalue( method = "BH") %>%
  rstatix::add_significance("p.adj") %>% 
  ungroup() -> gsva_aov

gsva_results %>% 
  group_by(Category) %>% 
  rstatix::tukey_hsd( Enrichment_Score ~ strain+AP_domain+LB_stage_binned) %>% 
  ungroup() %>% 
  as_tibble() -> gsva_tukey

gsva_aov %>% 
  as_tibble() %>% 
  filter( p.adj.signif != "ns" & !is.na(p.adj) ) -> signif_eff_terms

gsva_tukey %>% 
  inner_join( ., select( signif_eff_terms, Category, term = Effect)) -> signif_results_tukey

```

Below are the list of GO Biological processes that show significant differences by strain, AP domain and LB stage (adjusted p-value \< 0.05).


### GO BP terms and mammalian phenotypes showing significant differences 

```{r gsva_results_table}
#| warning: false
#| message: false
#| eval: false


signif_eff_terms %>% 
  filter( p.adj<0.05) %>% 
  filter( str_detect(Category, "GO:")) |> 
  left_join( goannot_wdef |> 
               select(Category = GOID, TERM) |> 
               distinct()) |> 
  rbind(
    signif_eff_terms |> 
      filter( p.adj < 0.01) |> 
      filter(str_detect(Category, "MP:")) |> 
      left_join( mp_defs |> 
                   select(Category = mp_id,
                          TERM = term_name))
  ) |> 
  select(Effect, Category, TERM,p.adj) %>% 
  #filter( p.adj < 0.01) %>% 
  distinct() %>% 
  mutate( "Adjusted p-value" = formatC(p.adj, digits=2, format ="e")) %>% 
  select(-p.adj) %>% 
  create_dt()



  
```

Let's simplify the GO terms that show significant differences between LB stage bins:

```{r simplify_gsva_lb}
#| warning: false
#| message: false
#| fig-height: 8
#| fig-width: 16
#| cache: true


gsva_lb_stage_terms <- signif_eff_terms %>% 
  filter( p.adj<0.01, Effect == "LB_stage_binned", str_detect(Category, "GO")) 

simplifyGO( mat = GO_similarity(gsva_lb_stage_terms$Category, ont = "BP"))

#compare_clustering_methods(GO_similarity(gsva_pn_go_terms$Category, ont = "BP"))

```

strain:
```{r simplify_gsva_strain}
#| warning: false
#| message: false
#| fig-height: 8
#| fig-width: 16
#| cache: true


gsva_strain_terms <- signif_eff_terms %>% 
  filter( p.adj<0.01, Effect == "strain", str_detect(Category, "GO")) 

simplifyGO( mat = GO_similarity(gsva_strain_terms$Category, ont = "BP"))



```

AP domain:
```{r simplify_gsva_domain}
#| warning: false
#| message: false
#| fig-height: 8
#| fig-width: 16
#| cache: true


gsva_domain_terms <- signif_eff_terms %>% 
  filter( p.adj<0.01, Effect == "AP_domain", str_detect(Category, "GO")) 

simplifyGO( mat = GO_similarity(gsva_domain_terms$Category, ont = "BP"))


```


# Weighted gene co-expression network analysis (WGCNA) 

```{r}
#| label: wgcna_prep_b6
#| warning: false
#| message: false

b6_samples <- sample_annot %>%
  filter(strain %in% c("B6")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
b6_cts_all <- round(raw_expr_mat[,rownames(b6_samples), drop = F])
b6_dds_all <- DESeqDataSetFromMatrix( countData = b6_cts_all,
                                  colData = b6_samples,
                                  design = ~1)
b6_dds_all <- collapseReplicates(b6_dds_all, b6_dds_all$unique_sampleid)
b6_dds_all_norm <- vst(b6_dds_all)
# b6_datExpr <- t(assay(b6_dds_all_norm))
b6_coldata <- colData(b6_dds_all) |> 
  as_tibble() |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage, Palate_ori) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")
# b6_gsg <- goodSamplesGenes(b6_datExpr)
# summary(b6_gsg)
b6_datTraits <- colData(b6_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori,strain) %>%
  mutate( strain = ifelse( strain == "B6",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
b6_datTraits_alt <- colData(b6_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori, strain) %>%
  column_to_rownames("unique_sampleid")

# 2. Following Ian's analysis to get most variable genes
B6rv_wpn <- rowVars(assay(b6_dds_all_norm))
B6q90_wpn <- quantile( rowVars(assay(b6_dds_all_norm)), .9)  # <= changed to 95 quantile to reduce dataset
b6_datExpr <- t(assay(b6_dds_all_norm)[ B6rv_wpn > B6q95_wpn, ])
b6_expr <- SummarizedExperiment(assays=list(counts=t(log1p(b6_datExpr))),
                                                 colData=b6_datTraits_alt)


```


```{r}
#| message: false
#| warning: false
#| label: wgcna_prep_cast
#| results: hide

# Let's prep the cast samples for later use here too
cast_samples <- sample_annot %>%
  filter(strain %in% c("CAST")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
cast_cts_all <- round(raw_expr_mat[,rownames(cast_samples), drop = F])
cast_dds_all <- DESeqDataSetFromMatrix( countData = cast_cts_all,
                                  colData = cast_samples,
                                  design = ~1)
cast_dds_all <- collapseReplicates(cast_dds_all, cast_dds_all$unique_sampleid)
cast_dds_all_norm <- vst(cast_dds_all)
# cast_datExpr <- t(assay(cast_dds_all_norm))
cast_coldata <- colData(cast_dds_all) |> 
  as_tibble() |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage,Palate_ori) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")


# cast_gsg <- goodSamplesGenes(cast_datExpr)
# summary(cast_gsg)
cast_datTraits <- colData(cast_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage,Palate_ori, strain) %>%
  mutate( strain = ifelse( strain == "CAST",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
cast_datTraits_alt <- colData(cast_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori,strain) %>%
  column_to_rownames("unique_sampleid")
# # Following Ian's analysis to get most variable genes
CASTrv_wpn <- rowVars(assay(cast_dds_all_norm))
# CASTq75_wpn <- quantile( rowVars(assay(cast_dds_all_norm)), .75)  # <= original
CASTq90_wpn <- quantile( rowVars(assay(cast_dds_all_norm)), .90)  # <= changed to 95 quantile to reduce dataset
cast_datExpr <- t(assay(cast_dds_all_norm)[ CASTrv_wpn > CASTq90_wpn, ])
# # convert to summarized experiment object for later use in bionero functions
cast_expr <- SummarizedExperiment(assays=list(counts=t(cast_datExpr)),
                     colData=cast_datTraits_alt)


```

```{r}
#| message: false
#| warning: false
#| label: wgcna_prep_do
#| results: hide

# Let's prep the do samples for later use here too
do_samples <- sample_annot_all %>%
  filter(strain %in% c("DO")) %>%
  separate(sample, sep = "_", into = c("s","e","d","ind","rep"), remove = F) %>%
  select(-e,-d) %>%
  mutate( rep = ifelse( is.na(rep),1,rep)) %>%
  unite( "unique_sampleid" , c(s,ind,AP_domain,Gest_stage),sep ="_", remove = F) |> # adding an individual column to match the domains to the same animal/embryo and rep column for replicates
  select(sample,unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, strain, LB_stage,Palate_ori) %>%
  filter(!is.na(sex) ) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("sample")

# # Using deseq2 to normalize the full gene expression matrix and collapse replicates.
do_cts_all <- round(raw_expr_mat[,rownames(do_samples), drop = F])
do_dds_all <- DESeqDataSetFromMatrix( countData = do_cts_all,
                                  colData = do_samples,
                                  design = ~1)
do_dds_all <- collapseReplicates(do_dds_all, do_dds_all$unique_sampleid)
do_dds_all_norm <- vst(do_dds_all)
# cast_datExpr <- t(assay(cast_dds_all_norm))
do_coldata <- colData(do_dds_all) |> 
  as_tibble() |> 
  select(unique_sampleid, sex,ind, rep, AP_domain, Gest_stage, LB_stage,Palate_ori) %>%
  mutate( AP_domain = factor(AP_domain, levels = c("PM","MAX","POST")) ) %>%
  column_to_rownames("unique_sampleid")

do_datTraits <- colData(do_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage,Palate_ori, strain) %>%
  mutate( strain = ifelse( strain == "CAST",0,1),
          sex = ifelse(sex == "M", 0, 1),
          AP_domain = case_when(
            AP_domain =="PM"~0,
            AP_domain =="MAX"~1,
            AP_domain =="POST"~2,
          ),
          Gest_stage = case_when(
            Gest_stage == "E12.5"~0,
            Gest_stage == "E13.5"~1,
            Gest_stage == "E14.5"~2,
            Gest_stage == "E15.5"~3,
          )) %>%
  column_to_rownames("unique_sampleid")
do_datTraits_alt <- colData(do_dds_all) %>%
  as_tibble() |> 
  select(unique_sampleid, sex, LB_stage, AP_domain, Gest_stage, Palate_ori,strain) %>%
  column_to_rownames("unique_sampleid")
# # Following Ian's analysis to get most variable genes
DOrv_wpn <- rowVars(assay(do_dds_all_norm))
# CASTq75_wpn <- quantile( rowVars(assay(cast_dds_all_norm)), .75)  # <= original
DOq90_wpn <- quantile( rowVars(assay(do_dds_all_norm)), .9)  # <= changed to 95 quantile to reduce dataset
do_datExpr <- t(assay(do_dds_all_norm)[ DOrv_wpn > DOq90_wpn, ])
# # convert to summarized experiment object for later use in bionero functions
do_expr <- SummarizedExperiment(assays=list(counts=t(do_datExpr)),
                     colData=do_datTraits_alt)


```

```{r}
#| label: prep_wgcna_all_three 

# Here I am subsetting the gene expression matrices to the genes that are most variable in B6 and CAST.

b6_expr_final <- b6_expr[ intersect(rownames(b6_expr), rownames(cast_expr)),,drop=F]
cast_expr_final <- cast_expr[ intersect(rownames(b6_expr), rownames(cast_expr)),,drop=F]
do_expr_final <- SummarizedExperiment(
  assays = list((assay(do_dds_all_norm)[ intersect(rownames(b6_expr), rownames(cast_expr)),,drop=F ])),
  colData = do_datTraits_alt)

```


Based on previous analyses, we settled on running WGCNA:

-   Using the intersection of genes between top 10% variable genes in B6 and CAST strains (n = `r formatC(nrow(b6_expr_final),big.mark=",")`).

-   Running WGCNA separately for each background, then comparing the modules.

::: {#WGCNA_results .panel-tabset .nav-pills}

## B6 

```{r}
#| warning: false
#| message: false
#| label: choose_sft_power_b6
#| results: hide

# Choose a set of soft-thresholding powers
b6_sft <- SFT_fit(b6_expr_final, net_type = "unsigned", cor_method = "biweight")
```

```{r}
#| label: sft_power_plot_b6
#| fig-width: 12
#| fig-height: 5
b6_sft$plot 
```


```{r}
#| label: run_wgcna_b6
#| warning: false
#| message: false
#| results: hide

power_b6 <- 17 # b6_sft$power

net_b6 <- exp2gcn(
    b6_expr_final, 
    net_type = "unsigned", 
    module_merging_threshold = 0.75,
    SFTpower = power_b6, 
    cor_method = "biweight"
)

plot_dendro_and_colors(net_b6)
plot_eigengene_network(net_b6)
plot_ngenes_per_module(net_b6)


```


Assessing module stability by re-sampling:

```{r}
#| label: module_stability_b6
#| warning: false
#| message: false
#| cache: true
#| results: hide
 

module_stability(b6_expr_final, net_b6, nRuns = 50)


```


Using `r formatC(nrow(b6_expr_final),big.mark=",")` genes and `r formatC(ncol(b6_expr_final),big.mark=",")` samples. This leads to `r ncol(net_b6$MEs)` modules in total which are characterized below. Remember the 'grey' module is a catch all module where WGCNA places the genes that cannot be assigned to any specific module.


::: {#WGCNA_results .panel-tabset .nav-pills}

### Module genes

```{r}
#| label: module_genes_table_b6
#| message: false
#| warning: false


net_b6$genes_and_modules |> 
  left_join( all_genes_palate |> 
               select( Genes = gene_id, symbol, chromosome)
            ) |> 
  group_by(Modules) |> 
  arrange(Modules, symbol) |> 
  create_dt()

```

### Module eigengenes

```{r}
#| label: module_eigengenes_all_b6
#| warning: false
#| message: false
#| results: asis
#| fig-width: 16
#| fig-height: 14

module_eigenges <- net_b6$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(b6_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long <-  module_eigenges |> 
  pivot_longer( 2:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = AP_domain)+
    geom_jitter()+
    geom_smooth( aes(col = AP_domain))+
    scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 3)


```

::: {#WGCNA_module_eigengenes .panel-tabset .nav-pills}
```{r}
#| label: module_eigengene_plots_b6
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

plot_eigengene_by_module_genes <- function(mod_name, module_eigengenes_long, expr, coldata,module_genes){
    
    df <- module_eigengenes_long |> 
      filter( module == mod_name) |> 
      arrange( value) |> 
      mutate( sample = as_factor(sample))
  
    eigengene_plot <- df |> 
      ggplot()+
      aes( y = value, x= LB_stage, col = AP_domain)+
      geom_jitter()+
      geom_smooth( aes(col = AP_domain))+
      scale_color_manual( values = domain_colors)+
      theme_pubclean(base_size = 16)+
      theme( legend.position = "top")+
      xlab("LB stage")+
      ylab("Module summary eigengene")
    
    mod_genes <- module_genes |> 
      filter(Modules ==gsub("ME","",mod_name))
    
    coldata_ordered <- coldata |> 
      as_tibble(rownames = "sample") |> 
      arrange(LB_stage,AP_domain) |> 
      column_to_rownames("sample") |> 
      as.matrix()
    
    mat <- log1p(assay(expr)[mod_genes$Genes, rownames(coldata_ordered), drop = FALSE])
    
    gene_plot <- pheatmap(mat = mat,
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = coldata[,c("AP_domain","LB_stage","Palate_ori","sex")],
         annotation_colors = list( 
                    #strain = strain_colors[c("cast","CAST")],
                    AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
                    ),
         treeheight_row = 0, 
         treeheight_col = 0,
         silent = TRUE
    )
    
    ggarrange( ggarrange(eigengene_plot,NULL, nrow = 1, widths = c(1, 0.2)), 
               ggarrange( NULL, gene_plot$gtable, widths = c(0.1, 1)),
               ncol = 1, nrow = 2, heights = c(.8,1))
}

module_genes <- net_b6$genes_and_modules
module_colors <- unique(module_eigengenes_long$mod_col)
names(module_colors) <- paste0("ME",module_colors)


for(mod in names(module_colors)){
  
  cat("\n#####",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_module_genes(mod, module_eigengenes_long, b6_expr_final, b6_coldata, module_genes))
  cat("\n \n")
  
}

# a <- plot_eigengene_by_samples("MEblack")
# ggsave(a, filename = here("_figures","test.pdf"), width = 8, height = 6)

```

:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_b6
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
b6_me_trait_cor <- c()
for(i in 1:(ncol(b6_datTraits_alt))){
  
  b6_me_trait_cor[[colnames(b6_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(b6_expr_final), # get just the expression
                                            metadata = b6_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_b6$MEs,
                                            continuous_trait = is.numeric(b6_datTraits_alt[1,i]),
                                            palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp_b6 <- reshape2::melt(b6_me_trait_cor) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  rename( "group"="L1") |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat_b6 <- reshape2::dcast(corandp_b6, ME ~ trait, value.var = "cor")
rownames(cormat_b6) <- cormat_b6$ME
cormat_b6$ME <- NULL
cormat_b6 <- as.matrix(cormat_b6)
cormat_b6[is.na(cormat_b6)] <- 0

pmat_b6 <- reshape2::dcast(corandp_b6, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat_b6) <- pmat_b6$ME
pmat_b6$ME <- NULL
pmat_b6[is.na(pmat_b6)] <- ""

```

```{r}
#| label: module_trait_cor_plot_b6
#| fig-width: 10
#| fig-height: 6
corrplot(corr = cormat_b6[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F],
         p.mat = as.matrix(pmat_b6[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(10,12), ylim=c(2,12), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r}
#| label: module_trait_cor_table_b6
#| warning: false
#| message: false
cormat[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:9, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:9, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

```{r }
#| label: wgcna_module_ora_b6
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
ora_results <- c()
modules <- unique(net_b6$genes_and_modules$Modules)
for( mod in modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_b6$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = all_genes_palate$symbol,
                        evcodes = TRUE)
  ora_results[[mod]] <- g.mod
}

```

```{r }
#| label: wgcna_ora_restuls_table_b6
#| eval: true
do.call( rbind, ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```
:::



## CAST

```{r}
#| warning: false
#| message: false
#| label: choose_sft_power_cast
#| results: hide

# Choose a set of soft-thresholding powers
cast_sft <- SFT_fit(cast_expr_final, net_type = "unsigned", cor_method = "biweight")
```

```{r}
#| label: sft_power_plot_cast
#| fig-width: 12
#| fig-height: 5
cast_sft$plot 
```


```{r}
#| label: run_wgcna_cast
#| warning: false
#| message: false
#| results: hide

power_cast <- cast_sft$power

net_cast <- exp2gcn(
    cast_expr_final, 
    net_type = "unsigned", 
    #module_merging_threshold = 0.75,
    SFTpower = power_cast, 
    cor_method = "biweight"
)

# plot_dendro_and_colors(net_cast)
# plot_eigengene_network(net_cast)
# plot_ngenes_per_module(net_cast)


```


Assessing module stability by re-sampling:

```{r}
#| label: module_stability_cast
#| warning: false
#| message: false
#| cache: true
#| results: hide
 

module_stability(cast_expr_final, net_cast, nRuns = 50)


```


Using `r formatC(nrow(cast_expr_final),big.mark=",")` genes and `r formatC(ncol(cast_expr_final),big.mark=",")` samples. This leads to `r ncol(net_cast$MEs)` modules in total which are characterized below. Remember the 'grey' module is a catch all module where WGCNA places the genes that cannot be assigned to any specific module.


::: {#WGCNA_results .panel-tabset .nav-pills}

### Module genes

```{r}
#| label: module_genes_table_cast
#| message: false
#| warning: false


net_cast$genes_and_modules |> 
  left_join( all_genes_palate |> 
               select( Genes = gene_id, symbol, chromosome)
            ) |> 
  group_by(Modules) |> 
  arrange(Modules, symbol) |> 
  create_dt()

```

### Module eigengenes

```{r}
#| label: module_eigengenes_all_cast
#| warning: false
#| message: false
#| results: asis
#| fig-width: 16
#| fig-height: 14

module_eigenges_cast <- net_cast$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(cast_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long_cast <-  module_eigenges_cast |> 
  pivot_longer( 2:MEgrey, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long_cast |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = AP_domain)+
    geom_jitter()+
    geom_smooth( aes(col = AP_domain))+
    scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 3)


```

::: {#WGCNA_module_eigengenes .panel-tabset .nav-pills}
```{r}
#| label: module_eigengene_plots_cast
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

plot_eigengene_by_module_genes <- function(mod_name, module_eigengenes_long, expr, coldata,module_genes){
    
    df <- module_eigengenes_long |> 
      filter( module == mod_name) |> 
      arrange( value) |> 
      mutate( sample = as_factor(sample))
  
    eigengene_plot <- df |> 
      ggplot()+
      aes( y = value, x= LB_stage, col = AP_domain)+
      geom_jitter()+
      geom_smooth( aes(col = AP_domain))+
      scale_color_manual( values = domain_colors)+
      theme_pubclean(base_size = 16)+
      theme( legend.position = "top")+
      xlab("LB stage")+
      ylab("Module summary eigengene")
    
    mod_genes <- module_genes |> 
      filter(Modules ==gsub("ME","",mod_name))
    
    coldata_ordered <- coldata |> 
      as_tibble(rownames = "sample") |> 
      arrange(LB_stage,AP_domain) |> 
      column_to_rownames("sample") |> 
      as.matrix()
    
    mat <- log1p(assay(expr)[mod_genes$Genes, rownames(coldata_ordered), drop = FALSE])
    
    gene_plot <- pheatmap(mat = mat,
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = coldata[,c("AP_domain","LB_stage","Palate_ori","sex")],
         annotation_colors = list( 
                    #strain = strain_colors[c("cast","CAST")],
                    AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
                    ),
         treeheight_row = 0, 
         treeheight_col = 0,
         silent = TRUE
    )
    
    ggarrange( ggarrange(eigengene_plot,NULL, nrow = 1, widths = c(1, 0.2)), 
               ggarrange( NULL, gene_plot$gtable, widths = c(0.1, 1)),
               ncol = 1, nrow = 2, heights = c(.8,1))
}

module_genes_cast <- net_cast$genes_and_modules
module_colors_cast <- unique(module_eigengenes_long_cast$mod_col)
names(module_colors_cast) <- paste0("ME",module_colors_cast)


for(mod in names(module_colors_cast)){
  
  cat("\n#####",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_module_genes(mod, module_eigengenes_long_cast, cast_expr_final, cast_coldata, module_genes_cast))
  cat("\n \n")
  
}


```

:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_cast
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
cast_me_trait_cor <- c()
for(i in 1:(ncol(cast_datTraits_alt))){
  
  cast_me_trait_cor[[colnames(cast_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(cast_expr_final), # get just the expression
                                            metadata = cast_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_cast$MEs,
                                            continuous_trait = is.numeric(cast_datTraits_alt[1,i]),
                                            palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp_cast <- reshape2::melt(cast_me_trait_cor) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  rename( "group"="L1") |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat_cast <- reshape2::dcast(corandp_cast, ME ~ trait, value.var = "cor")
rownames(cormat_cast) <- cormat_cast$ME
cormat_cast$ME <- NULL
cormat_cast <- as.matrix(cormat_cast)
cormat_cast[is.na(cormat_cast)] <- 0

pmat_cast <- reshape2::dcast(corandp_cast, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat_cast) <- pmat_cast$ME
pmat_cast$ME <- NULL
pmat_cast[is.na(pmat_cast)] <- ""

```

```{r}
#| label: module_trait_cor_plot_cast
#| fig-width: 10
#| fig-height: 6
corrplot(corr = cormat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F],
         p.mat = as.matrix(pmat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(10,12), ylim=c(2,12), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r}
#| label: module_trait_cor_table_cast
#| warning: false
#| message: false
cormat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:9, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat_cast[,c("M","F","PM","MAX","POST","LB_stage","Left","Right"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:9, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

```{r }
#| label: wgcna_module_ora_cast
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
ora_results <- c()
modules <- unique(net_cast$genes_and_modules$Modules)
for( mod in modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_cast$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = all_genes_palate$symbol,
                        evcodes = TRUE)
  ora_results[[mod]] <- g.mod
}

```

```{r }
#| label: wgcna_ora_restuls_table_cast
#| eval: true
do.call( rbind, ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```
:::

## Comparison of B6 and CAST modules

```{r}
#| label: compare_module_functions

calculate_overlap <- function(module1, module2, genes1, genes2) {
  intersection <- length(intersect(module1, module2))
  union <- length(unique(c(module1, module2)))
  jaccard <- if (union > 0) intersection / union else 0
  
  # Fisher's exact test
  m1_size <- length(module1)
  m2_size <- length(module2)
  total_genes <- length(union(genes1, genes2))
  
  # Create the contingency table
  contingency <- matrix(c(intersection, 
                          m1_size - intersection,
                          m2_size - intersection, 
                          total_genes - m1_size - m2_size + intersection),
                        nrow = 2)
  
  # Only perform Fisher's test if there's an overlap
  if (intersection > 0) {
    fisher_p <- fisher.test(contingency)$p.value
  } else {
    fisher_p <- 1  # No overlap means no significance
  }
  
  return(c(jaccard = jaccard, p_value = fisher_p, overlap = intersection))
}

compare_networks <- function(network1, network2) {
  modules1 <- split(network1$gene, network1$module)
  modules2 <- split(network2$gene, network2$module)
  genes1 <- unique(network1$gene)
  genes2 <- unique(network2$gene)
  
  results <- expand.grid(module1 = names(modules1), module2 = names(modules2))
  results$jaccard <- 0
  results$p_value <- 1
  results$overlap_count <- 0
  
  for (i in 1:nrow(results)) {
    m1 <- modules1[[results$module1[i]]]
    m2 <- modules2[[results$module2[i]]]
    overlap <- calculate_overlap(m1, m2, genes1, genes2)
    results$jaccard[i] <- overlap["jaccard"]
    results$p_value[i] <- overlap["p_value"]
    results$overlap_count[i] <- overlap["overlap"]
  }
  
  # Add module sizes
  results$size1 <- lengths(modules1)[results$module1]
  results$size2 <- lengths(modules2)[results$module2]
  
  return(results)
}

plot_module_overlap <- function(comparison_results, p_threshold = 0.05) {
  # Prepare data for plotting
  plot_data <- comparison_results %>%
    arrange(desc(overlap_count)) %>%
    mutate(
      text_color = ifelse(adj_p_value < p_threshold, "cyan", "black"),
      module1 = factor(module1, levels = unique(module1)),
      module2 = factor(module2, levels = unique(module2))
    )

  # Create the heatmap
  ggplot(plot_data, aes(x = module1, y = module2, fill = jaccard)) +
    geom_tile(color = "white") +
    scale_fill_viridis_b(
      option = "plasma",  # This gives a nice blue to yellow gradient
      name = "Jaccard Index"
    ) +
    geom_text(
      aes(label = overlap_count, color = text_color),
      size = 3
    ) +
    scale_color_identity() +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
      axis.title = element_text(face = "bold"),
      legend.position = "right",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    labs(
      x = "Network 1 Modules", 
      y = "Network 2 Modules", 
      title = "Module Overlap between Networks",
      subtitle = paste("Cyan text indicates significant overlap (adj. p <", p_threshold, ")")
    ) +
    coord_fixed()  # This ensures that the tiles are square
}

```

Overlap, Jaccard Index:
```{r}
#| label: compare_b6_to_cast
#| fig-height: 6
#| fig-width: 12

network1 <- net_b6$genes_and_modules |> 
  rename(gene = Genes, module = Modules)
network2 <- net_cast$genes_and_modules |> 
  rename(gene = Genes, module = Modules)

comparison_results <- compare_networks(network1, network2)
comparison_results$adj_p_value <- p.adjust(comparison_results$p_value, method = "BH")

# Create the plot
plot_module_overlap(comparison_results, p_threshold = 0.01)+
    labs(
      x = "B6", 
      y = "CAST"
      )
```


Module preservation:
```{r}
#| label: b6_cast_mod_preservation
#| warning: false
#| message: false


b6_and_cast <- c(b6=b6_expr_final, 
                 cast = cast_expr_final)

pres <- module_preservation( b6_and_cast,
                            ref_net = net_b6, 
                            test_net = net_cast, 
                            algorithm = "netrep",
                            nThreads = 40)

pres$p.values |> 
  as_tibble( rownames = "Module") |> 
  filter( `avg.weight` < 0.05 ) |> 
  mutate_if( is.numeric, formatC, digits =2 ) |> 
  create_dt()



```


```{r}

consensus <- consensus_modules(b6_and_cast, power = c(20,20), cor_method = "biweight", net_type = "unsigned")

names(consensus)


plot_dendro_and_cons_colors(consensus)

consensus_trait <- consensus_trait_cor(consensus, cor_method = "pearson")
head(consensus_trait)

```

:::
## DO - only MAX domain


```{r}
#| warning: false
#| message: false
#| label: choose_sft_power_do
#| results: hide

# Choose a set of soft-thresholding powers
do_sft <- SFT_fit(do_expr_final, net_type = "unsigned", cor_method = "biweight")
```

```{r}
#| label: sft_power_plot_do
#| fig-width: 12
#| fig-height: 5
do_sft$plot 
```


```{r}
#| label: run_wgcna_do
#| warning: false
#| message: false
#| results: hide

power_do <- do_sft$power

net_do <- exp2gcn(
    do_expr_final, 
    net_type = "unsigned", 
    #module_merging_threshold = 0.75,
    SFTpower = power_do, 
    cor_method = "biweight"
)

plot_dendro_and_colors(net_do)
plot_eigengene_network(net_do)
plot_ngenes_per_module(net_do)


```


Assessing module stability by re-sampling:

```{r}
#| label: module_stability_do
#| warning: false
#| message: false
#| cache: true
#| results: hide
 

module_stability(do_expr_final, net_do, nRuns = 50)


```


Using `r formatC(nrow(do_expr_final),big.mark=",")` genes and `r formatC(ncol(do_expr_final),big.mark=",")` samples. This leads to `r ncol(net_do$MEs)` modules in total which are characterized below. Remember the 'grey' module is a catch all module where WGCNA places the genes that cannot be assigned to any specific module.


::: {#WGCNA_results .panel-tabset .nav-pills}

### Module genes

```{r}
#| label: module_genes_table_do
#| message: false
#| warning: false


net_do$genes_and_modules |> 
  left_join( all_genes_palate |> 
               select( Genes = gene_id, symbol, chromosome)
            ) |> 
  group_by(Modules) |> 
  arrange(Modules, symbol) |> 
  create_dt()

```

### Module eigengenes

```{r}
#| label: module_eigengenes_all_do
#| warning: false
#| message: false
#| results: asis
#| fig-width: 16
#| fig-height: 5

module_eigenges_do <- net_do$MEs |> 
  as_tibble( rownames = "sample") |> 
  left_join(do_coldata |> 
              as_tibble(rownames= "sample"))


module_eigengenes_long_do <-  module_eigenges_do |> 
  pivot_longer( 2:MEblue, names_to = "module",values_to = "value") |> 
  mutate( mod_col = factor(gsub("ME","",module) ))

module_eigengenes_long_do |> 
    # filter( mod_col %in% c("yellow","pink","red","green","turquoise","blue")) |> 
    # mutate(mod_col = factor(mod_col, levels = c("red","pink","green","yellow","turquoise","blue"))) |> 
    ggplot()+
    aes( y = value, x= LB_stage, col = sex)+
    geom_jitter()+
    geom_smooth( aes(col = sex))+
    #scale_color_manual( values = domain_colors)+
    theme_pubclean(base_size = 16)+
    theme( legend.position = "top")+
    xlab("LB stage")+
    ylab("Module summary eigengene")+
    facet_wrap(~mod_col, nrow = 1)


```

::: {#WGCNA_module_eigengenes .panel-tabset .nav-pills}
```{r}
#| label: module_eigengene_plots_do
#| warning: false
#| message: false
#| results: asis
#| fig-width: 8
#| fig-height: 8

plot_eigengene_by_module_genes <- function(mod_name, module_eigengenes_long, expr, coldata,module_genes){
    
    df <- module_eigengenes_long |> 
      filter( module == mod_name) |> 
      arrange( value) |> 
      mutate( sample = as_factor(sample))
  
    eigengene_plot <- df |> 
      ggplot()+
      aes( y = value, x= LB_stage, col = sex)+
      geom_jitter()+
      geom_smooth( aes(col = sex))+
      #scale_color_manual( values = domain_colors)+
      theme_pubclean(base_size = 16)+
      theme( legend.position = "top")+
      xlab("LB stage")+
      ylab("Module summary eigengene")
    
    mod_genes <- module_genes |> 
      filter(Modules ==gsub("ME","",mod_name))
    
    coldata_ordered <- coldata |> 
      as_tibble(rownames = "sample") |> 
      arrange(LB_stage,sex) |> 
      column_to_rownames("sample") |> 
      as.matrix()
    
    mat <- log1p(assay(expr)[mod_genes$Genes, rownames(coldata_ordered), drop = FALSE])
    
    gene_plot <- pheatmap(mat = mat,
         show_rownames = F,
         show_colnames = F, 
         cluster_rows = T,
         cluster_cols = F,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         color = viridisLite::plasma(512, begin = 0, end = 1,direction = -1 ),
         annotation_col = coldata[,c("sex","LB_stage","Palate_ori")],
         annotation_colors = list( 
                    #strain = strain_colors[c("do","do")],
                    #AP_domain =domain_colors,
                    LB_stage = viridisLite::viridis(114,begin = 0, end = 1, direction = -1, option = "D")
                    ),
         treeheight_row = 0, 
         treeheight_col = 0,
         silent = TRUE
    )
    
    ggarrange( ggarrange(eigengene_plot,NULL, nrow = 1, widths = c(1, 0.2)), 
               ggarrange( NULL, gene_plot$gtable, widths = c(0.1, 1)),
               ncol = 1, nrow = 2, heights = c(.8,1))
}

module_genes_do <- net_do$genes_and_modules
module_colors_do <- unique(module_eigengenes_long_do$mod_col)
names(module_colors_do) <- paste0("ME",module_colors_do)


for(mod in names(module_colors_do)){
  
  cat("\n#####",gsub("ME","",mod), "module","\n")
  print(plot_eigengene_by_module_genes(mod, module_eigengenes_long_do, do_expr_final, do_coldata, module_genes_do))
  cat("\n \n")
  
}


```

:::

### Module-trait correlations

```{r}
#| label: module_trait_cor_do
#| warning: false
#| message: false
#| results: hide
#| fig-show: hide

# module trait correlations
# bioNERO function module_trait_cor can only handle one trait at a time! 
# but the fact that it separates each trait and shows the directionality makes things easier to interpret so I will use that and just loop over the traits.
do_me_trait_cor <- c()
for(i in 1:(ncol(do_datTraits_alt))){
  
  do_me_trait_cor[[colnames(do_datTraits_alt)[i]]] <- module_trait_cor( exp = assay(do_expr_final), # get just the expression
                                            metadata = do_datTraits_alt[,i,drop=F], # pass metadata manually
                                            MEs = net_do$MEs,
                                            continuous_trait = is.numeric(do_datTraits_alt[1,i]),
                                            palette = "PRGn",
                                            cor_method = "pearson"
                                            )
}

corandp_do <- reshape2::melt(do_me_trait_cor) |> 
  pivot_wider( names_from = variable, values_from = value) |> 
  rename( "group"="L1") |> 
  group_by( group) |> 
  rstatix::adjust_pvalue( p.col = "pvalue") |> 
  ungroup()
# some reshaping for pheatmap
cormat_do <- reshape2::dcast(corandp_do, ME ~ trait, value.var = "cor")
rownames(cormat_do) <- cormat_do$ME
cormat_do$ME <- NULL
cormat_do <- as.matrix(cormat_do)
cormat_do[is.na(cormat_do)] <- 0

pmat_do <- reshape2::dcast(corandp_do, ME ~ trait, value.var = "pvalue.adj")
rownames(pmat_do) <- pmat_do$ME
pmat_do$ME <- NULL
pmat_do[is.na(pmat_do)] <- ""

```

```{r}
#| label: module_trait_cor_plot_do
#| fig-width: 8
#| fig-height: 6
corrplot(corr = cormat_do[,c("M","F","LB_stage","Left","Right"),drop=F],
         p.mat = as.matrix(pmat_do[,c("M","F","LB_stage","Left","Right"),drop=F]),
         sig.level = 0.05,
         insig = "label_sig", 
         pch.cex = 1.3, 
         pch.col = "red",
         #rder = 'AOE', 
         cl.pos = 'n',
         col = COL2('PRGn'))
colorlegend(xlim=c(5.6,6.6), ylim=c(1,4), COL2('PRGn'), c(seq(-1,1,.5)), align="l", vertical=TRUE, addlabels=TRUE)

```

```{r}
#| label: module_trait_cor_table_do
#| warning: false
#| message: false
cormat_do[,c("M","F","LB_stage","Left","Right"),drop=F]|> 
  as_tibble(rownames = "module") |> 
  pivot_longer(2:9, names_to = "effect", values_to = "Correlation") |> 
  full_join(
    pmat_do[,c("M","F","LB_stage","Left","Right"),drop=F] |> 
      as_tibble(rownames = "module") |> 
      pivot_longer(2:9, names_to = "effect", values_to = "Adjusted p-value")
  ) |> 
  filter(`Adjusted p-value` < 0.05) |> 
  mutate_if(is.numeric, formatC, digits=2) |> 
  create_dt()

```

### ORA results for modules

```{r }
#| label: wgcna_module_ora_do
#| message: false
#| warning: false
#| cache: true
#| eval: true


## ORA for each module
ora_results <- c()
modules <- unique(net_do$genes_and_modules$Modules)
for( mod in modules){
  modGenes <- all_genes_palate[all_genes_palate$gene_id %in%
                                (net_do$genes_and_modules |> filter(Modules == mod))$Genes,]$symbol
  
  g.mod <- gost(query =  unique(modGenes),
                        organism = "mmusculus",
                        domain_scope = "custom",
                        custom_bg = all_genes_palate$symbol,
                        evcodes = TRUE)
  ora_results[[mod]] <- g.mod
}

```

```{r }
#| label: wgcna_ora_restuls_table_do
#| eval: true
do.call( rbind, ora_results) %>%
  as_tibble(rownames = "module") %>%
  select(-meta) %>%
  unnest("result") %>%
  select(module,  term_name, source, FDR = p_value, term_size, intersection_size,intersection) %>%
    filter( FDR <0.05, term_size < 500) %>%
  mutate_if( is.numeric, formatC, digits =2) %>%
  create_dt()


```
:::


## Comparison of DO modules with B6 and CAST


# Differential gene expression analysis using maSigPro

```{r masigpro_setup}
#| eval: false
library(maSigPro)
# Similar to Deseq, I am converting to counts
# The recommended analysis to deal with RNA-Seq data is the GLM with negative.binomial
# family. θ must be specified and it can be computed by using available methods as edgeR
# ((Robinson et al., 2010)). The application of maSigPro with several values of θ to the same
# datasets did not reveal significant differences in gene selection. Taking this into consideration
# we have put by default θ = 10 for being an average value. Moreover we give to the user the
# option of applying whatever exponential family to explore other possibilities.
# Data must be normalized before the application of maSigPro as it is not integrated any
# normalized method
# data: Gene by samples
b6_data <- round(assay(b6_dds_all_norm) )
b6_data <- b6_data[all_genes_palate$gene_id,,drop=F]
b6_design_data <- b6_coldata |> 
  as_tibble( rownames = "unique_sampleid") |> 
  left_join( b6_samples |> 
               as_tibble( rownames = "sample") |> 
               select(unique_sampleid, sample) |> 
               left_join(
                 sample_annot |> 
                   select(sample, LB_stage_binned)
               ) |> 
               select(unique_sampleid, LB_stage_binned) |> 
               distinct()
             ) |> 
  filter( LB_stage_binned != "exclude") |> 
  mutate(
    ind = as.numeric(ind),
    AP_domain_value = 1,
    Gest_stage = case_when(
            Gest_stage == "E12.5"~12.5,
            Gest_stage == "E13.5"~13.5,
            Gest_stage == "E14.5"~14.5,
            Gest_stage == "E15.5"~15.5,
          ),
    # I am doing the replicates as below to match the description in the user guide that says:" Replicates column is an index column that indicates the replicated arrays: all arrays belonging to the same experimental condition must be given the same number."
    Replicate = case_when(
      Gest_stage ==12.5 & AP_domain =="MAX"~1,
      Gest_stage ==13.5 & AP_domain =="MAX"~2,
      Gest_stage ==14.5 & AP_domain =="MAX"~3,
      Gest_stage ==15.5 & AP_domain =="MAX"~4,
      Gest_stage ==12.5 & AP_domain =="PM"~5,
      Gest_stage ==13.5 & AP_domain =="PM"~6,
      Gest_stage ==14.5 & AP_domain =="PM"~7,
      Gest_stage ==15.5 & AP_domain =="PM"~8,
      Gest_stage ==12.5 & AP_domain =="POST"~9,
      Gest_stage ==13.5 & AP_domain =="POST"~10,
      Gest_stage ==14.5 & AP_domain =="POST"~11,
      Gest_stage ==15.5 & AP_domain =="POST"~12
      )
    ) |> 
  pivot_wider( id_cols = c("unique_sampleid","Gest_stage","Replicate"), names_from= "AP_domain", values_from="AP_domain_value") |> 
  mutate(
    MAX = ifelse(is.na(MAX),0, MAX),
    PM = ifelse(is.na(PM),0, PM),
    POST = ifelse(is.na(POST),0, POST)
  ) |> 
  mutate( Time = Gest_stage) |> 
  arrange(Time,Replicate) |> 
  column_to_rownames("unique_sampleid")

b6_design <- make.design.matrix(b6_design_data[,c("Time","Replicate","MAX","PM","POST")], degree = 3, time.col = 1, group.cols = c(3:5), repl.col = 2)

#b6_design$groups.vector
fit <- p.vector(b6_data, b6_design, counts = TRUE)
tstep <- T.fit(fit)
get<-get.siggenes(tstep, vars="all")
library(mclust)
cluster_genes <- see.genes(get$sig.genes, 
                           k.mclust = TRUE, 
                           cluster.method = "Mclust")


unique(cluster_genes$cut)
```









